"""
Order Type Determination Module
Author: BLESSING OMOREGIE
GitHub: Nixiestone
Repository: nyx_trial

DO NOT EDIT THIS FILE
Determines appropriate order type based on price action and entry conditions.
"""

from enum import Enum
from typing import Dict, Tuple
from dataclasses import dataclass


class OrderType(Enum):
    """Order execution types."""
    MARKET = "Market Order"
    LIMIT = "Limit Order"
    STOP = "Stop Order"
    BUY_STOP = "Buy Stop"
    SELL_STOP = "Sell Stop"
    BUY_LIMIT = "Buy Limit"
    SELL_LIMIT = "Sell Limit"


@dataclass
class OrderDecision:
    """Order type decision with details."""
    order_type: OrderType
    execution_price: float
    reason: str
    immediate_execution: bool
    pending_order: bool


class OrderTypeDetector:
    """
    Determines the appropriate order type based on:
    - Current price vs Entry price
    - Direction (BUY/SELL)
    - Price action context
    """
    
    def __init__(self, price_tolerance_pips: float = 2.0):
        """
        Initialize order type detector.
        
        Args:
            price_tolerance_pips: Tolerance for considering price "at entry"
        """
        self.price_tolerance_pips = price_tolerance_pips
    
    def determine_order_type(
        self,
        symbol: str,
        direction: str,
        entry_price: float,
        current_price: float
    ) -> OrderDecision:
        """
        Determine the appropriate order type.
        
        Logic:
        1. MARKET ORDER: When price is already at or past entry
        2. LIMIT ORDER: When entry is better than current (buy lower, sell higher)
        3. STOP ORDER: When entry requires breakout (buy higher, sell lower)
        
        Args:
            symbol: Trading symbol
            direction: 'BUY' or 'SELL'
            entry_price: Desired entry price
            current_price: Current market price
            
        Returns:
            OrderDecision object
        """
        # Calculate pip difference
        pip_value = self._get_pip_value(symbol)
        price_diff = abs(entry_price - current_price)
        pip_diff = price_diff / pip_value
        
        # Check if price is within tolerance (execute at market)
        if pip_diff <= self.price_tolerance_pips:
            return OrderDecision(
                order_type=OrderType.MARKET,
                execution_price=current_price,
                reason=f"Price within {self.price_tolerance_pips} pips of entry",
                immediate_execution=True,
                pending_order=False
            )
        
        # BUY orders
        if direction.upper() == "BUY":
            if entry_price < current_price:
                # Want to buy LOWER than current = LIMIT ORDER
                # (Waiting for price to come down to us)
                return OrderDecision(
                    order_type=OrderType.BUY_LIMIT,
                    execution_price=entry_price,
                    reason=f"Entry {pip_diff:.1f} pips below current price - waiting for pullback",
                    immediate_execution=False,
                    pending_order=True
                )
            else:
                # Want to buy HIGHER than current = STOP ORDER
                # (Waiting for breakout/continuation)
                return OrderDecision(
                    order_type=OrderType.BUY_STOP,
                    execution_price=entry_price,
                    reason=f"Entry {pip_diff:.1f} pips above current price - waiting for breakout",
                    immediate_execution=False,
                    pending_order=True
                )
        
        # SELL orders
        elif direction.upper() == "SELL":
            if entry_price > current_price:
                # Want to sell HIGHER than current = LIMIT ORDER
                # (Waiting for price to come up to us)
                return OrderDecision(
                    order_type=OrderType.SELL_LIMIT,
                    execution_price=entry_price,
                    reason=f"Entry {pip_diff:.1f} pips above current price - waiting for pullback",
                    immediate_execution=False,
                    pending_order=True
                )
            else:
                # Want to sell LOWER than current = STOP ORDER
                # (Waiting for breakdown/continuation)
                return OrderDecision(
                    order_type=OrderType.SELL_STOP,
                    execution_price=entry_price,
                    reason=f"Entry {pip_diff:.1f} pips below current price - waiting for breakdown",
                    immediate_execution=False,
                    pending_order=True
                )
        
        # Default to market
        return OrderDecision(
            order_type=OrderType.MARKET,
            execution_price=current_price,
            reason="Default execution",
            immediate_execution=True,
            pending_order=False
        )
    
    def _get_pip_value(self, symbol: str) -> float:
        """Get pip value for a symbol."""
        if 'JPY' in symbol:
            return 0.01
        elif any(x in symbol for x in ['XAU', 'XAG', 'GOLD', 'SILVER']):
            return 0.01
        elif any(x in symbol for x in ['BTC', 'ETH', 'CRYPTO']):
            return 1.0
        elif any(x in symbol for x in ['US30', 'NAS100', 'SPX500']):
            return 1.0
        else:
            return 0.0001
    
    def get_order_type_description(self, order_decision: OrderDecision) -> str:
        """
        Get human-readable description of order type.
        
        Args:
            order_decision: OrderDecision object
            
        Returns:
            Formatted description
        """
        if order_decision.immediate_execution:
            return f"ðŸ”´ {order_decision.order_type.value} - EXECUTE NOW"
        else:
            return f"ðŸŸ¡ {order_decision.order_type.value} - PENDING"
    
    def should_execute_immediately(self, order_decision: OrderDecision) -> bool:
        """
        Check if order should execute immediately.
        
        Args:
            order_decision: OrderDecision object
            
        Returns:
            True if should execute now
        """
        return order_decision.immediate_execution


if __name__ == "__main__":
    # Test order type detector
    print("Testing Order Type Detector...")
    print("=" * 70)
    
    detector = OrderTypeDetector(price_tolerance_pips=2.0)
    
    # Test cases
    test_cases = [
        # (Symbol, Direction, Entry, Current, Expected)
        ("EURUSD", "BUY", 1.10000, 1.10000, "MARKET"),
        ("EURUSD", "BUY", 1.10000, 1.10001, "MARKET"),
        ("EURUSD", "BUY", 1.09950, 1.10000, "BUY_LIMIT"),
        ("EURUSD", "BUY", 1.10050, 1.10000, "BUY_STOP"),
        
        ("EURUSD", "SELL", 1.10000, 1.10000, "MARKET"),
        ("EURUSD", "SELL", 1.10050, 1.10000, "SELL_LIMIT"),
        ("EURUSD", "SELL", 1.09950, 1.10000, "SELL_STOP"),
        
        ("GBPJPY", "BUY", 189.00, 189.00, "MARKET"),
        ("GBPJPY", "BUY", 188.50, 189.00, "BUY_LIMIT"),
        ("GBPJPY", "BUY", 189.50, 189.00, "BUY_STOP"),
        
        ("XAUUSD", "SELL", 2000.00, 2000.00, "MARKET"),
        ("XAUUSD", "SELL", 2005.00, 2000.00, "SELL_LIMIT"),
        ("XAUUSD", "SELL", 1995.00, 2000.00, "SELL_STOP"),
    ]
    
    for symbol, direction, entry, current, expected_type in test_cases:
        decision = detector.determine_order_type(symbol, direction, entry, current)
        
        # Extract order type name
        actual_type = decision.order_type.name
        
        status = "âœ“" if expected_type in actual_type else "âœ—"
        
        print(f"{status} {symbol:8} {direction:4} | Entry: {entry:>8.5f} | "
              f"Current: {current:>8.5f} | {decision.order_type.value:15} | "
              f"{decision.reason}")
    
    print("=" * 70)
    print("\nOrder Type Detector test completed!")