"""
MetaTrader 5 Connection and Data Module
Author: BLESSING OMOREGIE
GitHub: Nixiestone
Repository: nyx_trial

DO NOT EDIT THIS FILE
Handles all MT5 connections and data retrieval.
"""

import MetaTrader5 as mt5
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Tuple
import pytz
from pathlib import Path

from ..utils.logger import get_logger


class MT5Connector:
    """
    Manages connection to MetaTrader 5 and data retrieval.
    """
    
    def __init__(self, config):
        """
        Initialize MT5 connector.
        
        Args:
            config: Settings object from config/settings.py
        """
        self.config = config
        self.logger = get_logger(__name__, config.LOG_LEVEL, config.LOG_FILE_PATH)
        self.connected = False
        self.account_info = None
        
        # Timezone for MT5 (UTC)
        self.timezone = pytz.timezone("UTC")
    
    def connect(self) -> bool:
        """
        Establish connection to MT5 terminal.
        
        Returns:
            True if connection successful, False otherwise
        """
        try:
            self.logger.info("Attempting to connect to MT5...")
            
            # Initialize MT5 connection
            if self.config.MT5_PATH:
                # Use specified path
                if not mt5.initialize(path=self.config.MT5_PATH):
                    self.logger.error(f"MT5 initialize failed: {mt5.last_error()}")
                    return False
            else:
                # Auto-detect MT5 installation
                if not mt5.initialize():
                    self.logger.error(f"MT5 initialize failed: {mt5.last_error()}")
                    return False
            
            # Login to trading account
            authorized = mt5.login(
                login=self.config.MT5_LOGIN,
                password=self.config.MT5_PASSWORD,
                server=self.config.MT5_SERVER,
                timeout=self.config.MT5_TIMEOUT
            )
            
            if not authorized:
                self.logger.error(f"MT5 login failed: {mt5.last_error()}")
                mt5.shutdown()
                return False
            
            # Get account information
            self.account_info = mt5.account_info()
            if self.account_info is None:
                self.logger.error("Failed to get account info")
                mt5.shutdown()
                return False
            
            self.connected = True
            
            self.logger.info(f"Connected to MT5 successfully!")
            self.logger.info(f"Account: {self.account_info.login}")
            self.logger.info(f"Server: {self.account_info.server}")
            self.logger.info(f"Balance: {self.account_info.balance}")
            self.logger.info(f"Currency: {self.account_info.currency}")
            
            return True
            
        except Exception as e:
            self.logger.exception(f"Error connecting to MT5: {e}")
            return False
    
    def disconnect(self):
        """Disconnect from MT5 terminal."""
        if self.connected:
            mt5.shutdown()
            self.connected = False
            self.logger.info("Disconnected from MT5")
    
    def get_account_info(self) -> Optional[Dict]:
        """
        Get current account information.
        
        Returns:
            Dictionary with account details or None
        """
        if not self.connected:
            self.logger.error("Not connected to MT5")
            return None
        
        try:
            account = mt5.account_info()
            if account is None:
                self.logger.error("Failed to get account info")
                return None
            
            return {
                'login': account.login,
                'server': account.server,
                'balance': account.balance,
                'equity': account.equity,
                'margin': account.margin,
                'margin_free': account.margin_free,
                'margin_level': account.margin_level,
                'profit': account.profit,
                'currency': account.currency,
                'leverage': account.leverage
            }
            
        except Exception as e:
            self.logger.exception(f"Error getting account info: {e}")
            return None
    
    def get_historical_data(
        self,
        symbol: str,
        timeframe: str,
        bars: int = 500
    ) -> Optional[pd.DataFrame]:
        """
        Get historical OHLCV data for a symbol.
        
        Args:
            symbol: Trading symbol (e.g., 'EURUSD')
            timeframe: Timeframe string (e.g., 'H4', 'M15')
            bars: Number of bars to retrieve
            
        Returns:
            DataFrame with OHLCV data or None
        """
        if not self.connected:
            self.logger.error("Not connected to MT5")
            return None
        
        try:
            # Convert timeframe string to MT5 constant
            mt5_timeframe = self._convert_timeframe(timeframe)
            if mt5_timeframe is None:
                self.logger.error(f"Invalid timeframe: {timeframe}")
                return None
            
            # Get rates
            rates = mt5.copy_rates_from_pos(symbol, mt5_timeframe, 0, bars)
            
            if rates is None or len(rates) == 0:
                self.logger.error(f"Failed to get rates for {symbol}: {mt5.last_error()}")
                return None
            
            # Convert to DataFrame
            df = pd.DataFrame(rates)
            
            # Convert time to datetime
            df['time'] = pd.to_datetime(df['time'], unit='s')
            
            # Set time as index
            df.set_index('time', inplace=True)
            
            # Rename columns to standard OHLCV format
            df.rename(columns={
                'open': 'open',
                'high': 'high',
                'low': 'low',
                'close': 'close',
                'tick_volume': 'volume',
                'spread': 'spread',
                'real_volume': 'real_volume'
            }, inplace=True)
            
            # Keep only OHLCV columns
            df = df[['open', 'high', 'low', 'close', 'volume']]
            
            self.logger.debug(f"Retrieved {len(df)} bars for {symbol} {timeframe}")
            
            return df
            
        except Exception as e:
            self.logger.exception(f"Error getting historical data: {e}")
            return None
    
    def get_historical_data_range(
        self,
        symbol: str,
        timeframe: str,
        start_date: datetime,
        end_date: datetime
    ) -> Optional[pd.DataFrame]:
        """
        Get historical data for a specific date range.
        
        Args:
            symbol: Trading symbol
            timeframe: Timeframe string
            start_date: Start datetime
            end_date: End datetime
            
        Returns:
            DataFrame with OHLCV data or None
        """
        if not self.connected:
            self.logger.error("Not connected to MT5")
            return None
        
        try:
            # Convert timeframe
            mt5_timeframe = self._convert_timeframe(timeframe)
            if mt5_timeframe is None:
                return None
            
            # Get rates for date range
            rates = mt5.copy_rates_range(
                symbol,
                mt5_timeframe,
                start_date,
                end_date
            )
            
            if rates is None or len(rates) == 0:
                self.logger.error(f"Failed to get rates for {symbol}")
                return None
            
            # Convert to DataFrame
            df = pd.DataFrame(rates)
            df['time'] = pd.to_datetime(df['time'], unit='s')
            df.set_index('time', inplace=True)
            
            df.rename(columns={
                'tick_volume': 'volume',
            }, inplace=True)
            
            df = df[['open', 'high', 'low', 'close', 'volume']]
            
            return df
            
        except Exception as e:
            self.logger.exception(f"Error getting date range data: {e}")
            return None
    
    def get_symbol_info(self, symbol: str) -> Optional[Dict]:
        """
        Get detailed information about a symbol.
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Dictionary with symbol information or None
        """
        if not self.connected:
            self.logger.error("Not connected to MT5")
            return None
        
        try:
            info = mt5.symbol_info(symbol)
            
            if info is None:
                self.logger.error(f"Failed to get symbol info for {symbol}")
                return None
            
            return {
                'name': info.name,
                'bid': info.bid,
                'ask': info.ask,
                'spread': info.spread,
                'digits': info.digits,
                'point': info.point,
                'trade_contract_size': info.trade_contract_size,
                'volume_min': info.volume_min,
                'volume_max': info.volume_max,
                'volume_step': info.volume_step,
                'currency_base': info.currency_base,
                'currency_profit': info.currency_profit,
                'currency_margin': info.currency_margin,
                'description': info.description
            }
            
        except Exception as e:
            self.logger.exception(f"Error getting symbol info: {e}")
            return None
    
    def get_current_price(self, symbol: str) -> Optional[Dict]:
        """
        Get current bid/ask prices for a symbol.
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Dictionary with bid and ask prices or None
        """
        if not self.connected:
            self.logger.error("Not connected to MT5")
            return None
        
        try:
            tick = mt5.symbol_info_tick(symbol)
            
            if tick is None:
                self.logger.error(f"Failed to get tick for {symbol}")
                return None
            
            return {
                'symbol': symbol,
                'bid': tick.bid,
                'ask': tick.ask,
                'last': tick.last,
                'time': datetime.fromtimestamp(tick.time)
            }
            
        except Exception as e:
            self.logger.exception(f"Error getting current price: {e}")
            return None
    
    def calculate_lot_size(
        self,
        symbol: str,
        risk_percent: float,
        stop_loss_pips: float
    ) -> float:
        """
        Calculate appropriate lot size based on risk management.
        Handles all pair types including JPY pairs, crypto, and indices.
        
        Args:
            symbol: Trading symbol
            risk_percent: Percentage of account to risk
            stop_loss_pips: Stop loss in pips
            
        Returns:
            Calculated lot size
        """
        try:
            account = self.get_account_info()
            if account is None:
                return self.config.MIN_LOT_SIZE
            
            symbol_info = self.get_symbol_info(symbol)
            if symbol_info is None:
                return self.config.MIN_LOT_SIZE
            
            # Calculate risk amount
            balance = account['balance']
            risk_amount = balance * (risk_percent / 100)
            
            # Get point value
            point = symbol_info['point']
            digits = symbol_info['digits']
            
            # Determine pip multiplier based on symbol type
            # JPY pairs: pip = 0.01 (2 digits after decimal)
            # Most forex: pip = 0.0001 (4 digits)
            # Crypto/Indices: pip = 1.0 or based on point
            if 'JPY' in symbol:
                pip_value_in_points = 0.01 / point  # JPY pairs
            elif digits == 5 or digits == 3:
                # 5-digit broker for forex or 3-digit for JPY
                pip_value_in_points = 10
            elif digits == 4 or digits == 2:
                # 4-digit broker for forex or 2-digit for JPY
                pip_value_in_points = 1
            else:
                # For indices, crypto, etc.
                pip_value_in_points = 1
            
            # Calculate pip value for 1 lot
            contract_size = symbol_info['trade_contract_size']
            pip_value_per_lot = contract_size * point * pip_value_in_points
            
            # For currency pairs where account currency differs
            # We need to convert the pip value
            account_currency = account['currency']
            quote_currency = symbol_info.get('currency_profit', '')
            
            if quote_currency and quote_currency != account_currency:
                # Need to convert (simplified, assuming direct rate)
                # In production, should fetch actual conversion rate
                conversion_rate = 1.0
                pip_value_per_lot *= conversion_rate
            
            # Calculate lot size
            lot_size = risk_amount / (stop_loss_pips * pip_value_per_lot)
            
            # Round to lot step
            lot_step = symbol_info['volume_step']
            lot_size = round(lot_size / lot_step) * lot_step
            
            # Apply min/max limits
            lot_size = max(symbol_info['volume_min'], lot_size)
            lot_size = min(symbol_info['volume_max'], lot_size)
            lot_size = min(self.config.MAX_LOT_SIZE, lot_size)
            
            self.logger.debug(
                f"Calculated lot size for {symbol}: {lot_size} "
                f"(Risk: {risk_amount:.2f}, SL: {stop_loss_pips} pips)"
            )
            
            return lot_size
            
        except Exception as e:
            self.logger.exception(f"Error calculating lot size: {e}")
            return self.config.MIN_LOT_SIZE
    
    def calculate_pips(
        self,
        symbol: str,
        price1: float,
        price2: float
    ) -> float:
        """
        Calculate pips between two prices for any symbol type.
        
        Args:
            symbol: Trading symbol
            price1: First price
            price2: Second price
            
        Returns:
            Pip difference
        """
        try:
            # Determine pip multiplier
            if 'JPY' in symbol:
                pip_multiplier = 100  # 0.01 for JPY pairs
            elif any(x in symbol for x in ['XAU', 'XAG', 'BTC', 'ETH']):
                pip_multiplier = 1  # 1.0 for metals and crypto
            elif any(x in symbol for x in ['US30', 'NAS100', 'SPX500']):
                pip_multiplier = 1  # 1.0 for indices
            else:
                pip_multiplier = 10000  # 0.0001 for most forex pairs
            
            pips = abs(price1 - price2) * pip_multiplier
            return pips
            
        except Exception as e:
            self.logger.error(f"Error calculating pips: {e}")
            return 0.0
    
    def _convert_timeframe(self, timeframe: str) -> Optional[int]:
        """
        Convert timeframe string to MT5 constant.
        
        Args:
            timeframe: Timeframe string (e.g., 'H4', 'M15')
            
        Returns:
            MT5 timeframe constant or None
        """
        timeframe_map = {
            'M1': mt5.TIMEFRAME_M1,
            'M5': mt5.TIMEFRAME_M5,
            'M15': mt5.TIMEFRAME_M15,
            'M30': mt5.TIMEFRAME_M30,
            'H1': mt5.TIMEFRAME_H1,
            'H4': mt5.TIMEFRAME_H4,
            'D1': mt5.TIMEFRAME_D1,
            'W1': mt5.TIMEFRAME_W1,
            'MN1': mt5.TIMEFRAME_MN1
        }
        
        return timeframe_map.get(timeframe)
    
    def check_connection(self) -> bool:
        """
        Check if connection is still active.
        
        Returns:
            True if connected, False otherwise
        """
        if not self.connected:
            return False
        
        try:
            info = mt5.account_info()
            return info is not None
        except:
            return False
    
    def __enter__(self):
        """Context manager entry."""
        self.connect()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.disconnect()


if __name__ == "__main__":
    # Test MT5 connection
    from config.settings import settings
    
    print("Testing MT5 Connection...")
    
    connector = MT5Connector(settings)
    
    if connector.connect():
        print("\nConnection successful!")
        
        # Get account info
        account = connector.get_account_info()
        if account:
            print(f"\nAccount Balance: {account['balance']} {account['currency']}")
            print(f"Equity: {account['equity']}")
            print(f"Leverage: 1:{account['leverage']}")
        
        # Test getting data
        symbol = "EURUSD"
        df = connector.get_historical_data(symbol, "H4", 100)
        
        if df is not None:
            print(f"\nRetrieved {len(df)} bars for {symbol}")
            print(f"Latest close: {df['close'].iloc[-1]}")
        
        connector.disconnect()
    else:
        print("\nConnection failed! Check your credentials in config/secrets.env")