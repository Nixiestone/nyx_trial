"""
Market Structure Detection Module
Author: BLESSING OMOREGIE
GitHub: Nixiestone
Repository: nyx_trial

DO NOT EDIT THIS FILE
Implements Smart Money Concepts market structure analysis.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum


class TrendDirection(Enum):
    """Market trend direction."""
    BULLISH = 1
    BEARISH = -1
    RANGING = 0


class StructureType(Enum):
    """Type of market structure break."""
    MSS = "Market Structure Shift"
    BOS = "Break of Structure"
    NONE = "No Structure Break"


@dataclass
class SwingPoint:
    """Represents a swing high or low point."""
    index: int
    price: float
    is_high: bool
    timestamp: Optional[pd.Timestamp] = None


@dataclass
class StructureBreak:
    """Represents a market structure break."""
    type: StructureType
    direction: TrendDirection
    break_index: int
    break_price: float
    broken_level: float
    confirmation: bool
    timestamp: Optional[pd.Timestamp] = None


class MarketStructureDetector:
    """
    Detects market structure using Smart Money Concepts.
    Identifies trends, swings, BOS, and MSS.
    """
    
    def __init__(self, swing_lookback: int = 5):
        """
        Initialize market structure detector.
        
        Args:
            swing_lookback: Number of candles to look back for swing detection
        """
        self.swing_lookback = swing_lookback
    
    def identify_swing_highs_lows(
        self,
        df: pd.DataFrame
    ) -> Tuple[List[SwingPoint], List[SwingPoint]]:
        """
        Identify swing highs and lows in price data.
        
        Args:
            df: DataFrame with OHLCV data
            
        Returns:
            Tuple of (swing_highs, swing_lows)
        """
        swing_highs = []
        swing_lows = []
        
        lookback = self.swing_lookback
        
        for i in range(lookback, len(df) - lookback):
            # Check for swing high
            current_high = df['high'].iloc[i]
            is_swing_high = True
            
            for j in range(1, lookback + 1):
                if (df['high'].iloc[i - j] >= current_high or 
                    df['high'].iloc[i + j] >= current_high):
                    is_swing_high = False
                    break
            
            if is_swing_high:
                swing_highs.append(SwingPoint(
                    index=i,
                    price=current_high,
                    is_high=True,
                    timestamp=df.index[i] if hasattr(df.index, 'to_timestamp') else None
                ))
            
            # Check for swing low
            current_low = df['low'].iloc[i]
            is_swing_low = True
            
            for j in range(1, lookback + 1):
                if (df['low'].iloc[i - j] <= current_low or 
                    df['low'].iloc[i + j] <= current_low):
                    is_swing_low = False
                    break
            
            if is_swing_low:
                swing_lows.append(SwingPoint(
                    index=i,
                    price=current_low,
                    is_high=False,
                    timestamp=df.index[i] if hasattr(df.index, 'to_timestamp') else None
                ))
        
        return swing_highs, swing_lows
    
    def determine_trend(
        self,
        swing_highs: List[SwingPoint],
        swing_lows: List[SwingPoint],
        recent_count: int = 3
    ) -> TrendDirection:
        """
        Determine market trend based on swing points.
        
        Args:
            swing_highs: List of swing high points
            swing_lows: List of swing low points
            recent_count: Number of recent swings to analyze
            
        Returns:
            TrendDirection enum
        """
        if len(swing_highs) < 2 or len(swing_lows) < 2:
            return TrendDirection.RANGING
        
        # Get recent swing points
        recent_highs = swing_highs[-min(recent_count, len(swing_highs)):]
        recent_lows = swing_lows[-min(recent_count, len(swing_lows)):]
        
        # Check for higher highs and higher lows (bullish)
        higher_highs = all(
            recent_highs[i].price > recent_highs[i-1].price 
            for i in range(1, len(recent_highs))
        )
        higher_lows = all(
            recent_lows[i].price > recent_lows[i-1].price 
            for i in range(1, len(recent_lows))
        )
        
        if higher_highs and higher_lows:
            return TrendDirection.BULLISH
        
        # Check for lower highs and lower lows (bearish)
        lower_highs = all(
            recent_highs[i].price < recent_highs[i-1].price 
            for i in range(1, len(recent_highs))
        )
        lower_lows = all(
            recent_lows[i].price < recent_lows[i-1].price 
            for i in range(1, len(recent_lows))
        )
        
        if lower_highs and lower_lows:
            return TrendDirection.BEARISH
        
        return TrendDirection.RANGING
    
    def detect_market_structure_shift(
        self,
        df: pd.DataFrame,
        swing_highs: List[SwingPoint],
        swing_lows: List[SwingPoint],
        current_trend: TrendDirection
    ) -> Optional[StructureBreak]:
        """
        Detect Market Structure Shift (MSS) - trend reversal.
        
        In an uptrend: MSS when price breaks previous higher low
        In a downtrend: MSS when price breaks previous lower high
        
        Args:
            df: DataFrame with OHLCV data
            swing_highs: List of swing highs
            swing_lows: List of swing lows
            current_trend: Current market trend
            
        Returns:
            StructureBreak object if MSS detected, None otherwise
        """
        if len(df) < 2:
            return None
        
        current_price = df['close'].iloc[-1]
        current_index = len(df) - 1
        
        # MSS in uptrend: break of previous higher low
        if current_trend == TrendDirection.BULLISH:
            if len(swing_lows) < 2:
                return None
            
            # Get the most recent higher low
            previous_low = swing_lows[-1]
            
            # Check if current price breaks below with body close
            if current_price < previous_low.price:
                return StructureBreak(
                    type=StructureType.MSS,
                    direction=TrendDirection.BEARISH,
                    break_index=current_index,
                    break_price=current_price,
                    broken_level=previous_low.price,
                    confirmation=True,
                    timestamp=df.index[-1] if hasattr(df.index, 'to_timestamp') else None
                )
        
        # MSS in downtrend: break of previous lower high
        elif current_trend == TrendDirection.BEARISH:
            if len(swing_highs) < 2:
                return None
            
            # Get the most recent lower high
            previous_high = swing_highs[-1]
            
            # Check if current price breaks above with body close
            if current_price > previous_high.price:
                return StructureBreak(
                    type=StructureType.MSS,
                    direction=TrendDirection.BULLISH,
                    break_index=current_index,
                    break_price=current_price,
                    broken_level=previous_high.price,
                    confirmation=True,
                    timestamp=df.index[-1] if hasattr(df.index, 'to_timestamp') else None
                )
        
        return None
    
    def detect_break_of_structure(
        self,
        df: pd.DataFrame,
        swing_highs: List[SwingPoint],
        swing_lows: List[SwingPoint],
        current_trend: TrendDirection
    ) -> Optional[StructureBreak]:
        """
        Detect Break of Structure (BOS) - trend continuation.
        
        In an uptrend: BOS when price breaks previous higher high
        In a downtrend: BOS when price breaks previous lower low
        
        Args:
            df: DataFrame with OHLCV data
            swing_highs: List of swing highs
            swing_lows: List of swing lows
            current_trend: Current market trend
            
        Returns:
            StructureBreak object if BOS detected, None otherwise
        """
        if len(df) < 2:
            return None
        
        current_price = df['close'].iloc[-1]
        current_index = len(df) - 1
        
        # BOS in uptrend: break of previous higher high
        if current_trend == TrendDirection.BULLISH:
            if len(swing_highs) < 1:
                return None
            
            # Get the most recent swing high
            previous_high = swing_highs[-1]
            
            # Check if current price breaks above with body close
            if current_price > previous_high.price:
                return StructureBreak(
                    type=StructureType.BOS,
                    direction=TrendDirection.BULLISH,
                    break_index=current_index,
                    break_price=current_price,
                    broken_level=previous_high.price,
                    confirmation=True,
                    timestamp=df.index[-1] if hasattr(df.index, 'to_timestamp') else None
                )
        
        # BOS in downtrend: break of previous lower low
        elif current_trend == TrendDirection.BEARISH:
            if len(swing_lows) < 1:
                return None
            
            # Get the most recent swing low
            previous_low = swing_lows[-1]
            
            # Check if current price breaks below with body close
            if current_price < previous_low.price:
                return StructureBreak(
                    type=StructureType.BOS,
                    direction=TrendDirection.BEARISH,
                    break_index=current_index,
                    break_price=current_price,
                    broken_level=previous_low.price,
                    confirmation=True,
                    timestamp=df.index[-1] if hasattr(df.index, 'to_timestamp') else None
                )
        
        return None
    
    def detect_double_bos(
        self,
        df: pd.DataFrame,
        swing_highs: List[SwingPoint],
        swing_lows: List[SwingPoint],
        current_trend: TrendDirection,
        lookback_breaks: int = 3
    ) -> bool:
        """
        Detect Double Break of Structure (Double BOS).
        Required for high-probability continuation setups.
        
        Args:
            df: DataFrame with OHLCV data
            swing_highs: List of swing highs
            swing_lows: List of swing lows
            current_trend: Current market trend
            lookback_breaks: Number of recent breaks to check
            
        Returns:
            True if double BOS detected, False otherwise
        """
        if current_trend == TrendDirection.BULLISH:
            if len(swing_highs) < 2:
                return False
            
            # Check if price has broken at least 2 recent highs
            recent_highs = swing_highs[-min(lookback_breaks, len(swing_highs)):]
            current_price = df['close'].iloc[-1]
            
            breaks_count = sum(1 for high in recent_highs if current_price > high.price)
            return breaks_count >= 2
        
        elif current_trend == TrendDirection.BEARISH:
            if len(swing_lows) < 2:
                return False
            
            # Check if price has broken at least 2 recent lows
            recent_lows = swing_lows[-min(lookback_breaks, len(swing_lows)):]
            current_price = df['close'].iloc[-1]
            
            breaks_count = sum(1 for low in recent_lows if current_price < low.price)
            return breaks_count >= 2
        
        return False
    
    def identify_inducement(
        self,
        df: pd.DataFrame,
        structure_break: StructureBreak,
        lookforward: int = 20
    ) -> Optional[SwingPoint]:
        """
        Identify inducement - the FIRST VALID PULLBACK after MSS or BOS.
        
        Inducement is the first retracement that price makes after breaking structure.
        It's where retail traders typically enter too early, before price sweeps it.
        
        Args:
            df: DataFrame with OHLCV data
            structure_break: The structure break (MSS or BOS) that occurred
            lookforward: Candles to look forward from structure break
            
        Returns:
            SwingPoint representing inducement, or None
        """
        if structure_break is None:
            return None
        
        break_index = structure_break.break_index
        
        # Make sure we have data after the break
        if break_index >= len(df) - 1:
            return None
        
        # Look at candles AFTER the structure break
        end_index = min(break_index + lookforward, len(df))
        candles_after_break = df.iloc[break_index + 1:end_index]
        
        if len(candles_after_break) < 2:
            return None
        
        # For BULLISH structure break (expecting upward movement)
        # Inducement = First pullback LOW after the break
        if structure_break.direction == TrendDirection.BULLISH:
            # Find the first time price pulls back (makes a lower low)
            for i in range(1, len(candles_after_break)):
                current_low = candles_after_break.iloc[i]['low']
                previous_low = candles_after_break.iloc[i-1]['low']
                
                # First pullback detected (lower low)
                if current_low < previous_low:
                    actual_index = break_index + 1 + i
                    return SwingPoint(
                        index=actual_index,
                        price=current_low,
                        is_high=False,
                        timestamp=df.index[actual_index] if hasattr(df.index, 'to_timestamp') else None
                    )
            
            # If no pullback found, use the lowest low after break
            if len(candles_after_break) > 0:
                min_idx = candles_after_break['low'].idxmin()
                min_idx_position = candles_after_break.index.get_loc(min_idx)
                actual_index = break_index + 1 + min_idx_position
                return SwingPoint(
                    index=actual_index,
                    price=candles_after_break.loc[min_idx, 'low'],
                    is_high=False,
                    timestamp=df.index[actual_index] if hasattr(df.index, 'to_timestamp') else None
                )
        
        # For BEARISH structure break (expecting downward movement)
        # Inducement = First pullback HIGH after the break
        elif structure_break.direction == TrendDirection.BEARISH:
            # Find the first time price pulls back (makes a higher high)
            for i in range(1, len(candles_after_break)):
                current_high = candles_after_break.iloc[i]['high']
                previous_high = candles_after_break.iloc[i-1]['high']
                
                # First pullback detected (higher high)
                if current_high > previous_high:
                    actual_index = break_index + 1 + i
                    return SwingPoint(
                        index=actual_index,
                        price=current_high,
                        is_high=True,
                        timestamp=df.index[actual_index] if hasattr(df.index, 'to_timestamp') else None
                    )
            
            # If no pullback found, use the highest high after break
            if len(candles_after_break) > 0:
                max_idx = candles_after_break['high'].idxmax()
                max_idx_position = candles_after_break.index.get_loc(max_idx)
                actual_index = break_index + 1 + max_idx_position
                return SwingPoint(
                    index=actual_index,
                    price=candles_after_break.loc[max_idx, 'high'],
                    is_high=True,
                    timestamp=df.index[actual_index] if hasattr(df.index, 'to_timestamp') else None
                )
        
        return None
    
    def analyze_market_structure(self, df: pd.DataFrame) -> Dict:
        """
        Complete market structure analysis.
        
        Args:
            df: DataFrame with OHLCV data
            
        Returns:
            Dictionary containing full structure analysis
        """
        # Identify swing points
        swing_highs, swing_lows = self.identify_swing_highs_lows(df)
        
        # Determine trend
        trend = self.determine_trend(swing_highs, swing_lows)
        
        # Detect structure breaks
        mss = self.detect_market_structure_shift(df, swing_highs, swing_lows, trend)
        bos = self.detect_break_of_structure(df, swing_highs, swing_lows, trend)
        double_bos = self.detect_double_bos(df, swing_highs, swing_lows, trend)
        
        # Identify inducement if structure break exists
        inducement = None
        if mss:
            inducement = self.identify_inducement(df, mss)
        elif bos:
            inducement = self.identify_inducement(df, bos)
        
        return {
            'trend': trend,
            'swing_highs': swing_highs,
            'swing_lows': swing_lows,
            'mss': mss,
            'bos': bos,
            'double_bos': double_bos,
            'inducement': inducement,
            'latest_swing_high': swing_highs[-1] if swing_highs else None,
            'latest_swing_low': swing_lows[-1] if swing_lows else None
        }


if __name__ == "__main__":
    # Test market structure detector
    print("Testing Market Structure Detector...")
    
    # Create sample data
    dates = pd.date_range('2024-01-01', periods=100, freq='1H')
    df = pd.DataFrame({
        'open': np.random.uniform(100, 110, 100),
        'high': np.random.uniform(110, 115, 100),
        'low': np.random.uniform(95, 100, 100),
        'close': np.random.uniform(100, 110, 100),
        'volume': np.random.uniform(1000, 2000, 100)
    }, index=dates)
    
    detector = MarketStructureDetector()
    analysis = detector.analyze_market_structure(df)
    
    print(f"Trend: {analysis['trend']}")
    print(f"Swing Highs: {len(analysis['swing_highs'])}")
    print(f"Swing Lows: {len(analysis['swing_lows'])}")
    print(f"MSS Detected: {analysis['mss'] is not None}")
    print(f"BOS Detected: {analysis['bos'] is not None}")
    print(f"Double BOS: {analysis['double_bos']}")
    
    print("\nMarket Structure Detector test completed!")