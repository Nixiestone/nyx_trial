"""
Point of Interest (POI) Detection Module
Author: BLESSING OMOREGIE
GitHub: Nixiestone
Repository: nyx_trial

DO NOT EDIT THIS FILE
Detects Order Blocks, Breaker Blocks, and Fair Value Gaps.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum


class POIType(Enum):
    """Type of Point of Interest."""
    ORDER_BLOCK = "OB"
    BREAKER_BLOCK = "BB"
    FAIR_VALUE_GAP = "FVG"


@dataclass
class PointOfInterest:
    """
    Represents a Point of Interest in the market.
    """
    poi_type: POIType
    price_high: float
    price_low: float
    candle_index: int
    body_high: float
    body_low: float
    triggered_structure: bool
    has_inducement: bool
    is_unmitigated: bool
    distance_to_liquidity: float
    direction: str  # 'bullish' or 'bearish'
    fvg_overlap: bool = False
    timestamp: Optional[pd.Timestamp] = None
    
    def is_valid(self) -> bool:
        """
        Check if POI meets all 4 rules for selection.
        
        Returns:
            True if POI is valid, False otherwise
        """
        return (
            self.triggered_structure and
            self.has_inducement and
            self.is_unmitigated and
            self.distance_to_liquidity >= 0
        )
    
    def get_entry_price(self, entry_type: str = "standard") -> float:
        """
        Calculate entry price based on entry type.
        
        Args:
            entry_type: 'standard' for 50% body or 'breaker' for body entry
            
        Returns:
            Entry price
        """
        if entry_type == "breaker" and self.poi_type == POIType.BREAKER_BLOCK:
            # Entry at body of breaker block
            return (self.body_high + self.body_low) / 2
        else:
            # Standard entry at 50% of candle body
            return (self.body_high + self.body_low) / 2


class POIDetector:
    """
    Detects Points of Interest: Order Blocks, Breaker Blocks, and Fair Value Gaps.
    """
    
    def __init__(
        self,
        timeframe: str = "M15",
        fvg_min_size_percent: float = 0.1
    ):
        """
        Initialize POI detector with elite candle-lookback logic.
        
        Args:
            timeframe: Trading timeframe (M5, M15, etc.)
            fvg_min_size_percent: Minimum FVG size as percentage
        """
        # Elite Candle Lookback Logic (Nixie SMC Engine)
        self.timeframe = timeframe
        
        # Structural Window (Primary Scan)
        if timeframe == "M5":
            self.primary_lookback = 120  # 10 hours (6-10 hour range: 72-120 candles)
            self.max_poi_distance = 40   # Freshness filter
        elif timeframe == "M15":
            self.primary_lookback = 150  # 37.5 hours (25-37 hour range: 100-150 candles)
            self.max_poi_distance = 60   # Adjusted for M15
        else:
            # Default for other timeframes
            self.primary_lookback = 100
            self.max_poi_distance = 50
        
        self.fvg_min_size_percent = fvg_min_size_percent
    
    def detect_order_blocks(
        self,
        df: pd.DataFrame,
        direction: str = "bullish",
        inducement_index: Optional[int] = None
    ) -> List[PointOfInterest]:
        """
        Detect Order Blocks using Elite 3-Step Candle Filter.
        
        ELITE LOGIC:
        Step A: IDM Anchor - Inducement is the zero point
        Step B: Search Zone - Last opposite-colored candle before IDM sweep
        Step C: Freshness Filter - Check mitigation (50% mean threshold)
        
        Args:
            df: DataFrame with OHLCV data
            direction: 'bullish' or 'bearish'
            inducement_index: Index of inducement (IDM anchor)
            
        Returns:
            List of PointOfInterest objects (sorted by proximity to IDM)
        """
        order_blocks = []
        
        # Step A: IDM Anchor
        # If inducement_index not provided, use recent price action
        if inducement_index is None:
            inducement_index = len(df) - 1
        
        # Step B: Search Zone - Primary Scan (last 120 candles for M5, 150 for M15)
        start_index = max(0, inducement_index - self.primary_lookback)
        
        for i in range(start_index, inducement_index):
            # Determine candle color
            is_bullish_candle = df['close'].iloc[i] > df['open'].iloc[i]
            is_bearish_candle = df['close'].iloc[i] < df['open'].iloc[i]
            
            # For bullish OB, find last bearish candle before displacement
            if direction == "bullish" and is_bearish_candle:
                # Check if followed by bullish displacement (2-3 strong candles)
                if i + 3 < len(df):
                    next_candles = df.iloc[i+1:min(i+4, len(df))]
                    bullish_displacement = (next_candles['close'] > next_candles['open']).sum() >= 2
                    
                    # Check for strong momentum (displacement)
                    displacement_range = next_candles['high'].max() - next_candles['low'].min()
                    avg_range = df['high'].iloc[i-5:i].sub(df['low'].iloc[i-5:i]).mean() if i >= 5 else displacement_range
                    
                    if bullish_displacement and displacement_range > avg_range * 1.5:
                        ob = PointOfInterest(
                            poi_type=POIType.ORDER_BLOCK,
                            price_high=df['high'].iloc[i],
                            price_low=df['low'].iloc[i],
                            candle_index=i,
                            body_high=max(df['open'].iloc[i], df['close'].iloc[i]),
                            body_low=min(df['open'].iloc[i], df['close'].iloc[i]),
                            triggered_structure=True,
                            has_inducement=False,  # Will be set later
                            is_unmitigated=self._check_mitigation_50_percent(df, i, inducement_index, direction),
                            distance_to_liquidity=self._calculate_distance_to_inducement(i, inducement_index),
                            direction=direction,
                            timestamp=df.index[i] if hasattr(df.index, 'to_timestamp') else None
                        )
                        
                        # Step C: Freshness Filter - Check POI distance
                        candle_distance = inducement_index - i
                        if candle_distance <= self.max_poi_distance:
                            order_blocks.append(ob)
            
            # For bearish OB, find last bullish candle before displacement
            elif direction == "bearish" and is_bullish_candle:
                # Check if followed by bearish displacement
                if i + 3 < len(df):
                    next_candles = df.iloc[i+1:min(i+4, len(df))]
                    bearish_displacement = (next_candles['close'] < next_candles['open']).sum() >= 2
                    
                    # Check for strong momentum
                    displacement_range = next_candles['high'].max() - next_candles['low'].min()
                    avg_range = df['high'].iloc[i-5:i].sub(df['low'].iloc[i-5:i]).mean() if i >= 5 else displacement_range
                    
                    if bearish_displacement and displacement_range > avg_range * 1.5:
                        ob = PointOfInterest(
                            poi_type=POIType.ORDER_BLOCK,
                            price_high=df['high'].iloc[i],
                            price_low=df['low'].iloc[i],
                            candle_index=i,
                            body_high=max(df['open'].iloc[i], df['close'].iloc[i]),
                            body_low=min(df['open'].iloc[i], df['close'].iloc[i]),
                            triggered_structure=True,
                            has_inducement=False,
                            is_unmitigated=self._check_mitigation_50_percent(df, i, inducement_index, direction),
                            distance_to_liquidity=self._calculate_distance_to_inducement(i, inducement_index),
                            direction=direction,
                            timestamp=df.index[i] if hasattr(df.index, 'to_timestamp') else None
                        )
                        
                        # Freshness Filter
                        candle_distance = inducement_index - i
                        if candle_distance <= self.max_poi_distance:
                            order_blocks.append(ob)
        
        # Sort by proximity to inducement (closest first) - ELITE PRIORITY
        order_blocks.sort(key=lambda x: x.distance_to_liquidity)
        
        return order_blocks
    
    def detect_breaker_blocks(
        self,
        df: pd.DataFrame,
        direction: str = "bullish",
        inducement_index: Optional[int] = None
    ) -> List[PointOfInterest]:
        """
        Detect Breaker Blocks using Elite Logic.
        
        BB: A failed Order Block that price broke through with high momentum (displacement),
        which then becomes support/resistance on the retest.
        
        Args:
            df: DataFrame with OHLCV data
            direction: 'bullish' or 'bearish'
            inducement_index: Index of inducement
            
        Returns:
            List of PointOfInterest objects (sorted by proximity)
        """
        breaker_blocks = []
        
        if inducement_index is None:
            inducement_index = len(df) - 1
        
        # Primary Scan within structural window
        start_index = max(0, inducement_index - self.primary_lookback)
        
        for i in range(start_index, inducement_index):
            candle_high = df['high'].iloc[i]
            candle_low = df['low'].iloc[i]
            body_high = max(df['open'].iloc[i], df['close'].iloc[i])
            body_low = min(df['open'].iloc[i], df['close'].iloc[i])
            
            # Check if this level was broken with displacement
            if i + 3 < len(df):
                # For bullish breaker: price breaks below with displacement, then holds above body
                if direction == "bullish":
                    # Check for break below with momentum
                    broke_below = df['low'].iloc[i+1] < candle_low
                    
                    # Check for displacement (strong move)
                    displacement_candles = df.iloc[i+1:min(i+4, len(df))]
                    has_displacement = (displacement_candles['close'] < displacement_candles['open']).sum() >= 2
                    
                    # Check if body held on retest (mitigation check on body only)
                    body_unmitigated = self._is_body_unmitigated(df, i, direction)
                    
                    if broke_below and has_displacement and body_unmitigated:
                        bb = PointOfInterest(
                            poi_type=POIType.BREAKER_BLOCK,
                            price_high=candle_high,
                            price_low=candle_low,
                            candle_index=i,
                            body_high=body_high,
                            body_low=body_low,
                            triggered_structure=True,
                            has_inducement=False,
                            is_unmitigated=body_unmitigated,
                            distance_to_liquidity=self._calculate_distance_to_inducement(i, inducement_index),
                            direction=direction,
                            timestamp=df.index[i] if hasattr(df.index, 'to_timestamp') else None
                        )
                        
                        # Freshness Filter
                        candle_distance = inducement_index - i
                        if candle_distance <= self.max_poi_distance:
                            breaker_blocks.append(bb)
                
                # For bearish breaker: price breaks above with displacement, then holds below body
                elif direction == "bearish":
                    broke_above = df['high'].iloc[i+1] > candle_high
                    
                    displacement_candles = df.iloc[i+1:min(i+4, len(df))]
                    has_displacement = (displacement_candles['close'] > displacement_candles['open']).sum() >= 2
                    
                    body_unmitigated = self._is_body_unmitigated(df, i, direction)
                    
                    if broke_above and has_displacement and body_unmitigated:
                        bb = PointOfInterest(
                            poi_type=POIType.BREAKER_BLOCK,
                            price_high=candle_high,
                            price_low=candle_low,
                            candle_index=i,
                            body_high=body_high,
                            body_low=body_low,
                            triggered_structure=True,
                            has_inducement=False,
                            is_unmitigated=body_unmitigated,
                            distance_to_liquidity=self._calculate_distance_to_inducement(i, inducement_index),
                            direction=direction,
                            timestamp=df.index[i] if hasattr(df.index, 'to_timestamp') else None
                        )
                        
                        # Freshness Filter
                        candle_distance = inducement_index - i
                        if candle_distance <= self.max_poi_distance:
                            breaker_blocks.append(bb)
        
        # Sort by proximity to inducement
        breaker_blocks.sort(key=lambda x: x.distance_to_liquidity)
        
        return breaker_blocks
    
    def detect_fair_value_gaps(
        self,
        df: pd.DataFrame,
        direction: str = "bullish"
    ) -> List[PointOfInterest]:
        """
        Detect Fair Value Gaps (FVG).
        
        FVG: A three-candle pattern where there's a gap between
        candle 1's high/low and candle 3's low/high.
        
        Args:
            df: DataFrame with OHLCV data
            direction: 'bullish' or 'bearish'
            
        Returns:
            List of PointOfInterest objects
        """
        fvgs = []
        
        for i in range(2, len(df)):
            # Bullish FVG: Gap between candle 1 high and candle 3 low
            if direction == "bullish":
                gap_bottom = df['high'].iloc[i-2]
                gap_top = df['low'].iloc[i]
                
                if gap_top > gap_bottom:
                    gap_size = gap_top - gap_bottom
                    gap_percent = (gap_size / gap_bottom) * 100
                    
                    if gap_percent >= self.fvg_min_size_percent:
                        fvg = PointOfInterest(
                            poi_type=POIType.FAIR_VALUE_GAP,
                            price_high=gap_top,
                            price_low=gap_bottom,
                            candle_index=i-1,
                            body_high=gap_top,
                            body_low=gap_bottom,
                            triggered_structure=True,
                            has_inducement=False,
                            is_unmitigated=self._is_fvg_unmitigated(df, i, gap_bottom, gap_top),
                            distance_to_liquidity=0.0,
                            direction=direction,
                            fvg_overlap=False,
                            timestamp=df.index[i-1] if hasattr(df.index, 'to_timestamp') else None
                        )
                        fvgs.append(fvg)
            
            # Bearish FVG: Gap between candle 1 low and candle 3 high
            elif direction == "bearish":
                gap_top = df['low'].iloc[i-2]
                gap_bottom = df['high'].iloc[i]
                
                if gap_top > gap_bottom:
                    gap_size = gap_top - gap_bottom
                    gap_percent = (gap_size / gap_top) * 100
                    
                    if gap_percent >= self.fvg_min_size_percent:
                        fvg = PointOfInterest(
                            poi_type=POIType.FAIR_VALUE_GAP,
                            price_high=gap_top,
                            price_low=gap_bottom,
                            candle_index=i-1,
                            body_high=gap_top,
                            body_low=gap_bottom,
                            triggered_structure=True,
                            has_inducement=False,
                            is_unmitigated=self._is_fvg_unmitigated(df, i, gap_bottom, gap_top),
                            distance_to_liquidity=0.0,
                            direction=direction,
                            fvg_overlap=False,
                            timestamp=df.index[i-1] if hasattr(df.index, 'to_timestamp') else None
                        )
                        fvgs.append(fvg)
        
        return fvgs
    
    def _check_mitigation_50_percent(
        self,
        df: pd.DataFrame,
        poi_index: int,
        inducement_index: int,
        direction: str
    ) -> bool:
        """
        ELITE MITIGATION CHECK - 50% Mean Threshold Rule.
        
        Step C: Freshness Filter
        Scan candles between POI and IDM.
        If any wick taps into 50% of the OB/BB, it is MITIGATED.
        
        Args:
            df: DataFrame with OHLCV data
            poi_index: Index of the POI candle
            inducement_index: Index of inducement
            direction: 'bullish' or 'bearish'
            
        Returns:
            True if UNMITIGATED (fresh), False if mitigated (stale)
        """
        if poi_index >= inducement_index:
            return True
        
        # Calculate 50% mean threshold of POI
        poi_high = df['high'].iloc[poi_index]
        poi_low = df['low'].iloc[poi_index]
        mean_threshold = (poi_high + poi_low) / 2
        
        # Scan candles between POI and IDM
        for i in range(poi_index + 1, inducement_index + 1):
            candle_high = df['high'].iloc[i]
            candle_low = df['low'].iloc[i]
            
            if direction == "bullish":
                # For bullish POI, check if any wick tapped below mean threshold
                if candle_low <= mean_threshold:
                    return False  # MITIGATED
            
            elif direction == "bearish":
                # For bearish POI, check if any wick tapped above mean threshold
                if candle_high >= mean_threshold:
                    return False  # MITIGATED
        
        return True  # UNMITIGATED (Fresh)
    
    def _calculate_distance_to_inducement(
        self,
        poi_index: int,
        inducement_index: int
    ) -> float:
        """
        Calculate candle distance from POI to Inducement.
        
        ELITE TIP: On M5, if POI is more than 40 candles from IDM,
        probability drops significantly (Institutional Intent is no longer fresh).
        
        Args:
            poi_index: Index of POI
            inducement_index: Index of inducement
            
        Returns:
            Distance in candles
        """
        return float(inducement_index - poi_index)
    
    def get_unicorn_setup_score(
        self,
        poi: PointOfInterest,
        fvgs: List[PointOfInterest]
    ) -> float:
        """
        Calculate Unicorn Setup Score.
        
        PROXIMITY RULE: If there are two OBs, the one with the Fair Value Gap (FVG)
        closest to it (The Unicorn Setup) scores the highest for the 3-Model Ensemble.
        
        Args:
            poi: Point of Interest to score
            fvgs: List of Fair Value Gaps
            
        Returns:
            Unicorn score (0.0 to 1.0, where 1.0 is perfect Unicorn)
        """
        if not fvgs:
            return 0.5  # No FVG = neutral score
        
        # Find closest FVG to this POI
        poi_mean = (poi.price_high + poi.price_low) / 2
        
        min_distance = float('inf')
        for fvg in fvgs:
            if fvg.direction == poi.direction:
                fvg_mean = (fvg.price_high + fvg.price_low) / 2
                distance = abs(poi_mean - fvg_mean)
                
                if distance < min_distance:
                    min_distance = distance
        
        # Score based on proximity (closer = higher score)
        # If FVG is within 20% of POI range, it's a strong Unicorn
        poi_range = poi.price_high - poi.price_low
        
        if min_distance == float('inf'):
            return 0.5
        
        if min_distance <= poi_range * 0.2:
            return 1.0  # Perfect Unicorn
        elif min_distance <= poi_range * 0.5:
            return 0.85  # Strong Unicorn
        elif min_distance <= poi_range * 1.0:
            return 0.7   # Good Unicorn
        else:
            return 0.5   # Weak correlation
    
    def _is_body_unmitigated(
        self,
        df: pd.DataFrame,
        candle_index: int,
        direction: str
    ) -> bool:
        """
        Check if POI body is unmitigated (for Breaker Blocks).
        
        Args:
            df: DataFrame with OHLCV data
            candle_index: Index of the POI candle
            direction: 'bullish' or 'bearish'
            
        Returns:
            True if body is unmitigated, False otherwise
        """
        if candle_index >= len(df) - 1:
            return True
        
        body_high = max(df['open'].iloc[candle_index], df['close'].iloc[candle_index])
        body_low = min(df['open'].iloc[candle_index], df['close'].iloc[candle_index])
        
        # Check subsequent candles
        for i in range(candle_index + 1, len(df)):
            if direction == "bullish":
                # For bullish breaker, check if price returned to body
                if df['low'].iloc[i] <= body_low:
                    return False
            elif direction == "bearish":
                # For bearish breaker, check if price returned to body
                if df['high'].iloc[i] >= body_high:
                    return False
        
        return True
    
    def _is_fvg_unmitigated(
        self,
        df: pd.DataFrame,
        candle_index: int,
        gap_low: float,
        gap_high: float
    ) -> bool:
        """
        Check if FVG is unmitigated.
        
        Args:
            df: DataFrame with OHLCV data
            candle_index: Index where FVG was created
            gap_low: Bottom of the gap
            gap_high: Top of the gap
            
        Returns:
            True if unmitigated, False otherwise
        """
        if candle_index >= len(df) - 1:
            return True
        
        # Check if price has filled the gap
        for i in range(candle_index + 1, len(df)):
            if df['low'].iloc[i] <= gap_low or df['high'].iloc[i] >= gap_high:
                return False
        
        return True
    
    def check_fvg_overlap(
        self,
        poi: PointOfInterest,
        fvgs: List[PointOfInterest]
    ) -> bool:
        """
        Check if POI overlaps with a Fair Value Gap (Unicorn Setup Check).
        
        ELITE: The Unicorn Setup = BB/OB overlapping with FVG.
        This is the highest probability setup for the 3-Model Ensemble.
        
        Args:
            poi: Point of Interest to check
            fvgs: List of Fair Value Gaps
            
        Returns:
            True if overlap exists (Unicorn Setup), False otherwise
        """
        for fvg in fvgs:
            if fvg.direction == poi.direction:
                # Check for overlap (any intersection of price ranges)
                overlap = not (
                    poi.price_high < fvg.price_low or
                    poi.price_low > fvg.price_high
                )
                if overlap:
                    # Calculate Unicorn score and attach to POI
                    poi.fvg_overlap = True
                    return True
        
        return False
    
    def select_optimal_poi(
        self,
        order_blocks: List[PointOfInterest],
        breaker_blocks: List[PointOfInterest],
        fvgs: List[PointOfInterest],
        scenario: str = "reversal"
    ) -> Optional[PointOfInterest]:
        """
        Select optimal POI using Elite Proximity Rule.
        
        PROXIMITY RULE: The POI with the FVG closest to it (Unicorn Setup)
        is the one the 3-Model Ensemble will score the highest.
        
        Args:
            order_blocks: List of detected OBs
            breaker_blocks: List of detected BBs
            fvgs: List of detected FVGs
            scenario: 'reversal' (prioritize OB) or 'continuation' (prioritize BB)
            
        Returns:
            Optimal PointOfInterest or None
        """
        candidates = []
        
        # Scenario-based prioritization
        if scenario == "reversal":
            # MSS: Prioritize OB, fallback to BB
            primary_list = order_blocks
            fallback_list = breaker_blocks
        else:  # continuation
            # Double BOS: Prioritize BB, fallback to OB
            primary_list = breaker_blocks
            fallback_list = order_blocks
        
        # Score primary candidates
        for poi in primary_list:
            if poi.is_valid():
                # Check FVG overlap
                has_fvg = self.check_fvg_overlap(poi, fvgs)
                
                # Calculate Unicorn score
                unicorn_score = self.get_unicorn_setup_score(poi, fvgs) if has_fvg else 0.5
                
                # Freshness bonus (closer to IDM = better)
                freshness_score = max(0, 1.0 - (poi.distance_to_liquidity / self.max_poi_distance))
                
                # Combined score
                total_score = (unicorn_score * 0.6) + (freshness_score * 0.4)
                
                candidates.append((poi, total_score))
        
        # If no valid primary POIs, try fallback
        if not candidates:
            for poi in fallback_list:
                if poi.is_valid():
                    has_fvg = self.check_fvg_overlap(poi, fvgs)
                    unicorn_score = self.get_unicorn_setup_score(poi, fvgs) if has_fvg else 0.5
                    freshness_score = max(0, 1.0 - (poi.distance_to_liquidity / self.max_poi_distance))
                    total_score = (unicorn_score * 0.6) + (freshness_score * 0.4)
                    candidates.append((poi, total_score))
        
        # Return highest scoring POI
        if candidates:
            candidates.sort(key=lambda x: x[1], reverse=True)
            return candidates[0][0]
        
        return None


if __name__ == "__main__":
    # Test POI detector
    print("Testing POI Detector...")
    
    # Create sample data
    dates = pd.date_range('2024-01-01', periods=100, freq='1H')
    df = pd.DataFrame({
        'open': np.random.uniform(100, 110, 100),
        'high': np.random.uniform(110, 115, 100),
        'low': np.random.uniform(95, 100, 100),
        'close': np.random.uniform(100, 110, 100),
        'volume': np.random.uniform(1000, 2000, 100)
    }, index=dates)
    
    detector = POIDetector()
    
    # Test Order Blocks
    obs = detector.detect_order_blocks(df, direction="bullish")
    print(f"Order Blocks detected: {len(obs)}")
    
    # Test Breaker Blocks
    bbs = detector.detect_breaker_blocks(df, direction="bullish")
    print(f"Breaker Blocks detected: {len(bbs)}")
    
    # Test Fair Value Gaps
    fvgs = detector.detect_fair_value_gaps(df, direction="bullish")
    print(f"Fair Value Gaps detected: {len(fvgs)}")
    
    print("\nPOI Detector test completed!")