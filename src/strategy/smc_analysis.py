"""
Smart Money Concepts (SMC) Analysis Module - COMPLETE
Author: BLESSING OMOREGIE
GitHub: Nixiestone
Repository: nyx_trial

DO NOT EDIT THIS FILE
Implements the complete SMC trading strategy logic.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

from .structure import MarketStructureDetector, TrendDirection, StructureType, StructureBreak
from .poi_detector import POIDetector, PointOfInterest, POIType


class ScenarioType(Enum):
    """Trading scenario type."""
    REVERSAL_MSS = "Reversal via Market Structure Shift"
    CONTINUATION_BOS = "Continuation via Break of Structure"
    NO_SETUP = "No Valid Setup"


@dataclass
class TradingSetup:
    """
    Complete trading setup with all components.
    """
    scenario: ScenarioType
    direction: str  # 'BUY' or 'SELL'
    poi: Optional[PointOfInterest]
    entry_price: float
    stop_loss: float
    take_profit_1: float
    take_profit_2: float
    risk_reward_tp1: float
    risk_reward_tp2: float
    structure_context: Dict
    inducement_swept: bool
    fvg_validation: bool
    confidence_score: float
    timestamp: pd.Timestamp
    
    def to_dict(self) -> Dict:
        """Convert setup to dictionary."""
        return {
            'scenario': self.scenario.value,
            'direction': self.direction,
            'poi_type': self.poi.poi_type.value if self.poi else None,
            'entry_price': self.entry_price,
            'stop_loss': self.stop_loss,
            'take_profit_1': self.take_profit_1,
            'take_profit_2': self.take_profit_2,
            'risk_reward_tp1': self.risk_reward_tp1,
            'risk_reward_tp2': self.risk_reward_tp2,
            'inducement_swept': self.inducement_swept,
            'fvg_validation': self.fvg_validation,
            'confidence_score': self.confidence_score,
            'timestamp': str(self.timestamp)
        }


class SMCAnalyzer:
    """
    Complete Smart Money Concepts analysis engine.
    Implements the full trading strategy logic.
    """
    
    def __init__(
        self,
        structure_detector: Optional[MarketStructureDetector] = None,
        poi_detector: Optional[POIDetector] = None,
        sl_padding_pips: float = 3.0,
        tp1_rr: float = 1.5,
        tp2_rr: float = 2.5
    ):
        """
        Initialize SMC analyzer.
        
        Args:
            structure_detector: Market structure detector instance
            poi_detector: POI detector instance
            sl_padding_pips: Stop loss padding in pips
            tp1_rr: Risk-reward ratio for TP1
            tp2_rr: Risk-reward ratio for TP2
        """
        self.structure_detector = structure_detector or MarketStructureDetector()
        self.poi_detector = poi_detector or POIDetector()
        self.sl_padding_pips = sl_padding_pips
        self.tp1_rr = tp1_rr
        self.tp2_rr = tp2_rr
    
    def analyze_htf_context(
        self,
        df_htf: pd.DataFrame
    ) -> Dict:
        """
        Phase 1: Analyze Higher Timeframe context (4H or Daily).
        
        Args:
            df_htf: DataFrame with HTF data
            
        Returns:
            Dictionary with HTF analysis
        """
        # Get complete market structure
        structure = self.structure_detector.analyze_market_structure(df_htf)
        
        # Detect all POI types
        direction_str = "bullish" if structure['trend'] == TrendDirection.BULLISH else "bearish"
        
        order_blocks = self.poi_detector.detect_order_blocks(
            df_htf,
            direction=direction_str
        )
        
        breaker_blocks = self.poi_detector.detect_breaker_blocks(
            df_htf,
            direction=direction_str
        )
        
        fvgs = self.poi_detector.detect_fair_value_gaps(
            df_htf,
            direction=direction_str
        )
        
        return {
            'trend': structure['trend'],
            'swing_highs': structure['swing_highs'],
            'swing_lows': structure['swing_lows'],
            'latest_swing_high': structure['latest_swing_high'],
            'latest_swing_low': structure['latest_swing_low'],
            'order_blocks': order_blocks,
            'breaker_blocks': breaker_blocks,
            'fair_value_gaps': fvgs,
            'mss': structure['mss'],
            'bos': structure['bos']
        }
    
    def analyze_itf_setup(
        self,
        df_itf: pd.DataFrame,
        htf_context: Dict
    ) -> Tuple[Optional[ScenarioType], Optional[StructureBreak]]:
        """
        Phase 2: Analyze Intermediate Timeframe for setup (15m or 1H).
        
        Args:
            df_itf: DataFrame with ITF data
            htf_context: HTF context from Phase 1
            
        Returns:
            Tuple of (scenario_type, structure_break)
        """
        # Get ITF market structure
        itf_structure = self.structure_detector.analyze_market_structure(df_itf)
        
        htf_trend = htf_context['trend']
        
        # Scenario A: Reversal via MSS
        if itf_structure['mss'] is not None:
            mss = itf_structure['mss']
            # MSS must be confirmed with body close
            if mss.confirmation:
                return ScenarioType.REVERSAL_MSS, mss
        
        # Scenario B: Continuation via Double BOS
        if itf_structure['bos'] is not None:
            bos = itf_structure['bos']
            # Check for double BOS
            double_bos = self.structure_detector.detect_double_bos(
                df_itf,
                itf_structure['swing_highs'],
                itf_structure['swing_lows'],
                itf_structure['trend']
            )
            
            if double_bos and bos.confirmation:
                # BOS must align with HTF trend
                if (htf_trend == TrendDirection.BULLISH and bos.direction == TrendDirection.BULLISH) or \
                   (htf_trend == TrendDirection.BEARISH and bos.direction == TrendDirection.BEARISH):
                    return ScenarioType.CONTINUATION_BOS, bos
        
        return ScenarioType.NO_SETUP, None
    
    def select_optimal_poi(
        self,
        scenario: ScenarioType,
        structure_break: StructureBreak,
        htf_context: Dict,
        df_itf: pd.DataFrame,
        df_ltf: pd.DataFrame
    ) -> Optional[PointOfInterest]:
        """
        Select optimal POI using ELITE NIXIE SMC ENGINE logic.
        
        ELITE 3-STEP FILTER:
        Step A: IDM Anchor (Inducement as zero point)
        Step B: Search Zone (Primary scan within structural window)
        Step C: Freshness Filter (50% mitigation + proximity check)
        
        PROXIMITY RULE: POI with FVG closest to it = Unicorn Setup (highest score)
        
        Args:
            scenario: Trading scenario type
            structure_break: The structure break that occurred
            htf_context: HTF context
            df_itf: ITF DataFrame
            df_ltf: LTF DataFrame
            
        Returns:
            Selected PointOfInterest or None
        """
        direction_str = "bullish" if structure_break.direction == TrendDirection.BULLISH else "bearish"
        
        # Step A: Identify Inducement (IDM Anchor - Zero Point)
        inducement = self.structure_detector.identify_inducement(df_ltf, structure_break)
        inducement_index = inducement.index if inducement else len(df_ltf) - 1
        
        # Determine timeframe for POI detector
        # Use LTF timeframe (M5 or M15) for elite candle lookback
        ltf_timeframe = self.config.LTF_TIMEFRAME if hasattr(self, 'config') else "M15"
        
        # Initialize POI detector with elite logic
        from .poi_detector import POIDetector
        elite_poi_detector = POIDetector(timeframe=ltf_timeframe)
        
        # Step B: Search Zone - Detect POIs within Primary Scan window
        order_blocks = elite_poi_detector.detect_order_blocks(
            df_ltf,
            direction=direction_str,
            inducement_index=inducement_index
        )
        
        breaker_blocks = elite_poi_detector.detect_breaker_blocks(
            df_ltf,
            direction=direction_str,
            inducement_index=inducement_index
        )
        
        fvgs = elite_poi_detector.detect_fair_value_gaps(
            df_ltf,
            direction=direction_str
        )
        
        # Step C: Select optimal POI using Elite Proximity Rule
        scenario_str = "reversal" if scenario == ScenarioType.REVERSAL_MSS else "continuation"
        
        optimal_poi = elite_poi_detector.select_optimal_poi(
            order_blocks,
            breaker_blocks,
            fvgs,
            scenario=scenario_str
        )
        
        if optimal_poi:
            # Calculate Unicorn score for ML ensemble
            unicorn_score = elite_poi_detector.get_unicorn_setup_score(optimal_poi, fvgs)
            optimal_poi.unicorn_score = unicorn_score
            
            # Attach inducement info
            optimal_poi.has_inducement = inducement is not None
        
        return optimal_poi
    
    def validate_entry_conditions(
        self,
        df_ltf: pd.DataFrame,
        poi: PointOfInterest,
        structure_break: StructureBreak
    ) -> Tuple[bool, bool]:
        """
        Phase 3: Validate entry conditions on Lower Timeframe.
        
        Args:
            df_ltf: DataFrame with LTF data
            poi: Selected Point of Interest
            structure_break: Structure break from ITF
            
        Returns:
            Tuple of (inducement_swept, fvg_validation)
        """
        # Check if inducement has been swept
        inducement = self.structure_detector.identify_inducement(
            df_ltf,
            structure_break
        )
        
        inducement_swept = False
        if inducement:
            current_price = df_ltf['close'].iloc[-1]
            if structure_break.direction == TrendDirection.BULLISH:
                inducement_swept = df_ltf['low'].iloc[-5:].min() <= inducement.price
            else:
                inducement_swept = df_ltf['high'].iloc[-5:].max() >= inducement.price
        
        # Validate FVG overlap requirement
        fvg_validation = False
        if poi.poi_type == POIType.ORDER_BLOCK:
            fvg_validation = poi.fvg_overlap
        elif poi.poi_type == POIType.BREAKER_BLOCK:
            fvg_validation = poi.fvg_overlap  # Unicorn model
        else:
            fvg_validation = True  # FVG itself is valid
        
        return inducement_swept, fvg_validation
    
    def calculate_risk_levels(
        self,
        poi: PointOfInterest,
        direction: str,
        current_price: float,
        htf_context: Dict
    ) -> Dict:
        """
        Phase 4: Calculate risk management levels.
        
        Args:
            poi: Selected Point of Interest
            direction: Trade direction ('BUY' or 'SELL')
            current_price: Current market price
            htf_context: HTF context for liquidity levels
            
        Returns:
            Dictionary with entry, SL, and TP levels
        """
        # Calculate entry price
        if poi.poi_type == POIType.BREAKER_BLOCK:
            entry_price = poi.get_entry_price("breaker")
        else:
            entry_price = poi.get_entry_price("standard")
        
        # Calculate Stop Loss (distal line + padding)
        if direction == "BUY":
            distal_line = poi.price_low
            stop_loss = distal_line - (self.sl_padding_pips * 0.0001)  # Assuming forex pips
        else:  # SELL
            distal_line = poi.price_high
            stop_loss = distal_line + (self.sl_padding_pips * 0.0001)
        
        # Calculate risk amount
        risk_amount = abs(entry_price - stop_loss)
        
        # Calculate Take Profits
        if direction == "BUY":
            # TP1: Internal Range Liquidity (latest swing high)
            tp1_target = htf_context.get('latest_swing_high')
            if tp1_target:
                take_profit_1 = tp1_target.price
            else:
                take_profit_1 = entry_price + (risk_amount * self.tp1_rr)
            
            # TP2: External Range Liquidity (higher swing high)
            swing_highs = htf_context.get('swing_highs', [])
            if len(swing_highs) >= 2:
                take_profit_2 = swing_highs[-2].price
            else:
                take_profit_2 = entry_price + (risk_amount * self.tp2_rr)
        
        else:  # SELL
            # TP1: Internal Range Liquidity (latest swing low)
            tp1_target = htf_context.get('latest_swing_low')
            if tp1_target:
                take_profit_1 = tp1_target.price
            else:
                take_profit_1 = entry_price - (risk_amount * self.tp1_rr)
            
            # TP2: External Range Liquidity (lower swing low)
            swing_lows = htf_context.get('swing_lows', [])
            if len(swing_lows) >= 2:
                take_profit_2 = swing_lows[-2].price
            else:
                take_profit_2 = entry_price - (risk_amount * self.tp2_rr)
        
        # Calculate actual risk-reward ratios
        rr_tp1 = abs(take_profit_1 - entry_price) / risk_amount if risk_amount > 0 else 0
        rr_tp2 = abs(take_profit_2 - entry_price) / risk_amount if risk_amount > 0 else 0
        
        return {
            'entry_price': entry_price,
            'stop_loss': stop_loss,
            'take_profit_1': take_profit_1,
            'take_profit_2': take_profit_2,
            'risk_amount': risk_amount,
            'risk_reward_tp1': rr_tp1,
            'risk_reward_tp2': rr_tp2
        }
    
    def generate_trading_setup(
        self,
        df_htf: pd.DataFrame,
        df_itf: pd.DataFrame,
        df_ltf: pd.DataFrame,
        ml_prediction: Optional[Dict] = None,
        sentiment_score: Optional[Dict] = None
    ) -> Optional[TradingSetup]:
        """
        Generate complete trading setup using ELITE NIXIE SMC ENGINE.
        
        ELITE CANDLE-LOOKBACK LOGIC:
        - M5: Primary scan 120 candles (10 hours), Max POI distance 40 candles
        - M15: Primary scan 150 candles (37.5 hours), Max POI distance 60 candles
        
        3-STEP ELITE FILTER:
        Step A: IDM Anchor (Inducement = Zero Point)
        Step B: Search Zone (Primary scan within structural window)
        Step C: Freshness Filter (50% mitigation + proximity)
        
        UNICORN SETUP: POI with closest FVG = highest ML ensemble score
        
        Args:
            df_htf: Higher timeframe DataFrame (4H/Daily)
            df_itf: Intermediate timeframe DataFrame (1H/15M)
            df_ltf: Lower timeframe DataFrame (15M/5M)
            ml_prediction: ML model predictions (optional)
            sentiment_score: Sentiment analysis results (optional)
            
        Returns:
            TradingSetup object or None if no valid setup
        """
        # Phase 1: HTF Context
        htf_context = self.analyze_htf_context(df_htf)
        
        # Check if HTF trend is clear
        if htf_context['trend'] == TrendDirection.RANGING:
            return None
        
        # Phase 2: ITF Setup
        scenario, structure_break = self.analyze_itf_setup(df_itf, htf_context)
        
        if scenario == ScenarioType.NO_SETUP or structure_break is None:
            return None
        
        # Phase 2.5: ELITE POI Selection using LTF with candle-lookback logic
        poi = self.select_optimal_poi(scenario, structure_break, htf_context, df_itf, df_ltf)
        
        if poi is None:
            return None
        
        # Phase 3: LTF Validation
        inducement_swept, fvg_validation = self.validate_entry_conditions(
            df_ltf,
            poi,
            structure_break
        )
        
        # ELITE: FVG validation is critical for Unicorn setups
        if not fvg_validation:
            return None
        
        # Determine direction
        direction = "BUY" if structure_break.direction == TrendDirection.BULLISH else "SELL"
        
        # Phase 4: Calculate risk levels
        current_price = df_ltf['close'].iloc[-1]
        risk_levels = self.calculate_risk_levels(poi, direction, current_price, htf_context)
        
        # Calculate confidence score with Unicorn bonus
        confidence_score = self._calculate_confidence_score(
            scenario=scenario,
            inducement_swept=inducement_swept,
            fvg_validation=fvg_validation,
            ml_prediction=ml_prediction,
            sentiment_score=sentiment_score,
            direction=direction,
            poi=poi  # Pass POI for Unicorn scoring
        )
        
        # Create trading setup
        setup = TradingSetup(
            scenario=scenario,
            direction=direction,
            poi=poi,
            entry_price=risk_levels['entry_price'],
            stop_loss=risk_levels['stop_loss'],
            take_profit_1=risk_levels['take_profit_1'],
            take_profit_2=risk_levels['take_profit_2'],
            risk_reward_tp1=risk_levels['risk_reward_tp1'],
            risk_reward_tp2=risk_levels['risk_reward_tp2'],
            structure_context=htf_context,
            inducement_swept=inducement_swept,
            fvg_validation=fvg_validation,
            confidence_score=confidence_score,
            timestamp=df_ltf.index[-1] if hasattr(df_ltf.index, 'to_timestamp') else pd.Timestamp.now()
        )
        
        return setup
    
    def _calculate_confidence_score(
        self,
        scenario: ScenarioType,
        inducement_swept: bool,
        fvg_validation: bool,
        ml_prediction: Optional[Dict],
        sentiment_score: Optional[Dict],
        direction: str,
        poi: Optional[PointOfInterest] = None
    ) -> float:
        """
        Calculate confidence score with ELITE UNICORN BONUS.
        
        UNICORN SETUP BONUS: POI with FVG overlap gets highest score.
        
        Args:
            scenario: Trading scenario
            inducement_swept: Whether inducement was swept
            fvg_validation: Whether FVG validation passed
            ml_prediction: ML predictions
            sentiment_score: Sentiment analysis
            direction: Trade direction
            poi: Point of Interest (for Unicorn scoring)
            
        Returns:
            Confidence score between 0 and 1
        """
        score = 0.0
        
        # Base score from SMC components (50% weight)
        smc_score = 0.0
        
        # Scenario type (10%)
        if scenario == ScenarioType.CONTINUATION_BOS:
            smc_score += 0.10  # Higher confidence for continuation
        else:
            smc_score += 0.07  # Lower for reversal
        
        # Inducement swept (10%)
        if inducement_swept:
            smc_score += 0.10
        
        # FVG validation (10%)
        if fvg_validation:
            smc_score += 0.10
        
        # POI quality (10%)
        if poi and poi.is_valid():
            smc_score += 0.10
        
        # ELITE UNICORN BONUS (10%)
        if poi and hasattr(poi, 'unicorn_score'):
            # Unicorn setup gets massive boost
            unicorn_bonus = poi.unicorn_score * 0.10
            smc_score += unicorn_bonus
        elif poi and poi.fvg_overlap:
            # Even without score, FVG overlap is worth 7%
            smc_score += 0.07
        
        score += smc_score
        
        # ML prediction score (30% weight) - ELITE: Unicorn setups score higher
        if ml_prediction:
            ml_score = 0.0
            ensemble_prediction = ml_prediction.get('ensemble', 0)
            ml_confidence = ml_prediction.get('confidence', 0.0)
            
            # Check if ML agrees with direction
            if (direction == "BUY" and ensemble_prediction == 1) or \
               (direction == "SELL" and ensemble_prediction == -1):
                ml_score = 0.30 * ml_confidence
                
                # UNICORN BOOST: If it's a Unicorn setup AND ML agrees, add bonus
                if poi and hasattr(poi, 'unicorn_score') and poi.unicorn_score >= 0.85:
                    ml_score *= 1.15  # 15% boost to ML score
            
            score += ml_score
        
        # Sentiment score (20% weight)
        if sentiment_score:
            sentiment_value = sentiment_score.get('score', 0.0)
            sentiment_confidence = sentiment_score.get('confidence', 0.0)
            
            # Check if sentiment agrees with direction
            if (direction == "BUY" and sentiment_value > 0) or \
               (direction == "SELL" and sentiment_value < 0):
                score += 0.20 * sentiment_confidence
        
        # Normalize to 0-1 range
        score = min(1.0, max(0.0, score))
        
        return round(score, 2)
    
    def should_take_trade(
        self,
        setup: TradingSetup,
        min_confidence: float = 0.6,
        min_risk_reward: float = 1.5
    ) -> Tuple[bool, str]:
        """
        Determine if a trade should be taken based on criteria.
        
        Args:
            setup: Trading setup
            min_confidence: Minimum confidence score required
            min_risk_reward: Minimum risk-reward ratio required
            
        Returns:
            Tuple of (should_trade, reason)
        """
        # Check confidence
        if setup.confidence_score < min_confidence:
            return False, f"Confidence too low: {setup.confidence_score} < {min_confidence}"
        
        # Check risk-reward ratio
        if setup.risk_reward_tp1 < min_risk_reward:
            return False, f"Risk-reward too low: {setup.risk_reward_tp1} < {min_risk_reward}"
        
        # Check FVG validation
        if not setup.fvg_validation:
            return False, "FVG validation failed"
        
        # All checks passed
        return True, "All criteria met"


if __name__ == "__main__":
    # Test SMC Analyzer
    print("Testing SMC Analyzer...")
    
    # Create sample data for testing
    dates = pd.date_range('2024-01-01', periods=500, freq='1H')
    
    # HTF data (4H timeframe)
    df_htf = pd.DataFrame({
        'open': np.random.uniform(100, 110, 500),
        'high': np.random.uniform(110, 115, 500),
        'low': np.random.uniform(95, 100, 500),
        'close': np.random.uniform(100, 110, 500),
        'volume': np.random.uniform(1000, 2000, 500)
    }, index=dates)
    
    # ITF data (1H timeframe)
    df_itf = pd.DataFrame({
        'open': np.random.uniform(100, 110, 500),
        'high': np.random.uniform(110, 115, 500),
        'low': np.random.uniform(95, 100, 500),
        'close': np.random.uniform(100, 110, 500),
        'volume': np.random.uniform(1000, 2000, 500)
    }, index=dates)
    
    # LTF data (15M timeframe)
    df_ltf = pd.DataFrame({
        'open': np.random.uniform(100, 110, 500),
        'high': np.random.uniform(110, 115, 500),
        'low': np.random.uniform(95, 100, 500),
        'close': np.random.uniform(100, 110, 500),
        'volume': np.random.uniform(1000, 2000, 500)
    }, index=dates)
    
    # Initialize analyzer
    analyzer = SMCAnalyzer()
    
    # Generate setup
    setup = analyzer.generate_trading_setup(df_htf, df_itf, df_ltf)
    
    if setup:
        print("\nTrading Setup Generated:")
        print(f"Scenario: {setup.scenario.value}")
        print(f"Direction: {setup.direction}")
        print(f"Entry: {setup.entry_price}")
        print(f"Stop Loss: {setup.stop_loss}")
        print(f"TP1: {setup.take_profit_1} (RR: {setup.risk_reward_tp1})")
        print(f"TP2: {setup.take_profit_2} (RR: {setup.risk_reward_tp2})")
        print(f"Confidence: {setup.confidence_score}")
        
        should_trade, reason = analyzer.should_take_trade(setup)
        print(f"\nShould Take Trade: {should_trade}")
        print(f"Reason: {reason}")
    else:
        print("\nNo valid setup found")
    
    print("\nSMC Analyzer test completed!")