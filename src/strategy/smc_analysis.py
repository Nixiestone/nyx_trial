"""
Smart Money Concepts (SMC) Analysis Module - COMPLETE
Author: BLESSING OMOREGIE
GitHub: Nixiestone
Repository: nyx_trial

DO NOT EDIT THIS FILE
Implements the complete SMC trading strategy logic.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

from .structure import MarketStructureDetector, TrendDirection, StructureType, StructureBreak
from .poi_detector import POIDetector, PointOfInterest, POIType


class ScenarioType(Enum):
    """Trading scenario type."""
    REVERSAL_MSS = "Reversal via Market Structure Shift"
    CONTINUATION_BOS = "Continuation via Break of Structure"
    NO_SETUP = "No Valid Setup"


@dataclass
class TradingSetup:
    """
    Complete trading setup with all components.
    """
    scenario: ScenarioType
    direction: str  # 'BUY' or 'SELL'
    poi: Optional[PointOfInterest]
    entry_price: float
    stop_loss: float
    take_profit_1: float
    take_profit_2: float
    risk_reward_tp1: float
    risk_reward_tp2: float
    structure_context: Dict
    inducement_swept: bool
    fvg_validation: bool
    confidence_score: float
    timestamp: pd.Timestamp
    
    def to_dict(self) -> Dict:
        """Convert setup to dictionary."""
        return {
            'scenario': self.scenario.value,
            'direction': self.direction,
            'poi_type': self.poi.poi_type.value if self.poi else None,
            'entry_price': self.entry_price,
            'stop_loss': self.stop_loss,
            'take_profit_1': self.take_profit_1,
            'take_profit_2': self.take_profit_2,
            'risk_reward_tp1': self.risk_reward_tp1,
            'risk_reward_tp2': self.risk_reward_tp2,
            'inducement_swept': self.inducement_swept,
            'fvg_validation': self.fvg_validation,
            'confidence_score': self.confidence_score,
            'timestamp': str(self.timestamp)
        }


class SMCAnalyzer:
    """
    Complete Smart Money Concepts analysis engine.
    Implements the full trading strategy logic.
    """
    
    def __init__(
        self,
        structure_detector: Optional[MarketStructureDetector] = None,
        poi_detector: Optional[POIDetector] = None,
        sl_padding_pips: float = 3.0,
        tp1_rr: float = 1.5,
        tp2_rr: float = 2.5
    ):
        """
        Initialize SMC analyzer.
        
        Args:
            structure_detector: Market structure detector instance
            poi_detector: POI detector instance
            sl_padding_pips: Stop loss padding in pips
            tp1_rr: Risk-reward ratio for TP1
            tp2_rr: Risk-reward ratio for TP2
        """
        self.structure_detector = structure_detector or MarketStructureDetector()
        self.poi_detector = poi_detector or POIDetector()
        self.sl_padding_pips = sl_padding_pips
        self.tp1_rr = tp1_rr
        self.tp2_rr = tp2_rr
    
    def analyze_htf_context(
        self,
        df_htf: pd.DataFrame
    ) -> Dict:
        """
        Phase 1: Analyze Higher Timeframe context (4H or Daily).
        
        Args:
            df_htf: DataFrame with HTF data
            
        Returns:
            Dictionary with HTF analysis
        """
        # Get complete market structure
        structure = self.structure_detector.analyze_market_structure(df_htf)
        
        # Detect all POI types
        direction_str = "bullish" if structure['trend'] == TrendDirection.BULLISH else "bearish"
        
        order_blocks = self.poi_detector.detect_order_blocks(
            df_htf,
            direction=direction_str
        )
        
        breaker_blocks = self.poi_detector.detect_breaker_blocks(
            df_htf,
            direction=direction_str
        )
        
        fvgs = self.poi_detector.detect_fair_value_gaps(
            df_htf,
            direction=direction_str
        )
        
        return {
            'trend': structure['trend'],
            'swing_highs': structure['swing_highs'],
            'swing_lows': structure['swing_lows'],
            'latest_swing_high': structure['latest_swing_high'],
            'latest_swing_low': structure['latest_swing_low'],
            'order_blocks': order_blocks,
            'breaker_blocks': breaker_blocks,
            'fair_value_gaps': fvgs,
            'mss': structure['mss'],
            'bos': structure['bos']
        }
    
    def analyze_itf_setup(
        self,
        df_itf: pd.DataFrame,
        htf_context: Dict
    ) -> Tuple[Optional[ScenarioType], Optional[StructureBreak]]:
        """
        Phase 2: Analyze Intermediate Timeframe for setup (15m or 1H).
        
        Args:
            df_itf: DataFrame with ITF data
            htf_context: HTF context from Phase 1
            
        Returns:
            Tuple of (scenario_type, structure_break)
        """
        # Get ITF market structure
        itf_structure = self.structure_detector.analyze_market_structure(df_itf)
        
        htf_trend = htf_context['trend']
        
        # Scenario A: Reversal via MSS
        if itf_structure['mss'] is not None:
            mss = itf_structure['mss']
            # MSS must be confirmed with body close
            if mss.confirmation:
                return ScenarioType.REVERSAL_MSS, mss
        
        # Scenario B: Continuation via Double BOS
        if itf_structure['bos'] is not None:
            bos = itf_structure['bos']
            # Check for double BOS
            double_bos = self.structure_detector.detect_double_bos(
                df_itf,
                itf_structure['swing_highs'],
                itf_structure['swing_lows'],
                itf_structure['trend']
            )
            
            if double_bos and bos.confirmation:
                # BOS must align with HTF trend
                if (htf_trend == TrendDirection.BULLISH and bos.direction == TrendDirection.BULLISH) or \
                   (htf_trend == TrendDirection.BEARISH and bos.direction == TrendDirection.BEARISH):
                    return ScenarioType.CONTINUATION_BOS, bos
        
        return ScenarioType.NO_SETUP, None
    
    def select_optimal_poi(
        self,
        scenario: ScenarioType,
        structure_break: StructureBreak,
        htf_context: Dict,
        df_itf: pd.DataFrame
    ) -> Optional[PointOfInterest]:
        """
        Select optimal POI based on scenario and priority logic.
        
        Args:
            scenario: Trading scenario type
            structure_break: The structure break that occurred
            htf_context: HTF context
            df_itf: ITF DataFrame
            
        Returns:
            Selected PointOfInterest or None
        """
        direction_str = "bullish" if structure_break.direction == TrendDirection.BULLISH else "bearish"
        
        # Get ITF POIs
        order_blocks = self.poi_detector.detect_order_blocks(
            df_itf,
            direction=direction_str,
            structure_break_index=structure_break.break_index
        )
        
        breaker_blocks = self.poi_detector.detect_breaker_blocks(
            df_itf,
            direction=direction_str,
            structure_break_index=structure_break.break_index
        )
        
        fvgs = self.poi_detector.detect_fair_value_gaps(
            df_itf,
            direction=direction_str
        )
        
        # Scenario A (MSS): Prioritize OB, fallback to BB
        if scenario == ScenarioType.REVERSAL_MSS:
            # 1. Look for Order Block first
            valid_obs = [ob for ob in order_blocks if ob.is_valid()]
            if valid_obs:
                # Select OB closest to current price
                current_price = df_itf['close'].iloc[-1]
                closest_ob = min(
                    valid_obs,
                    key=lambda ob: abs((ob.price_high + ob.price_low) / 2 - current_price)
                )
                # Check FVG overlap
                closest_ob.fvg_overlap = self.poi_detector.check_fvg_overlap(closest_ob, fvgs)
                return closest_ob
            
            # 2. Fallback to Breaker Block
            valid_bbs = [bb for bb in breaker_blocks if bb.is_valid()]
            if valid_bbs:
                current_price = df_itf['close'].iloc[-1]
                closest_bb = min(
                    valid_bbs,
                    key=lambda bb: abs((bb.price_high + bb.price_low) / 2 - current_price)
                )
                closest_bb.fvg_overlap = self.poi_detector.check_fvg_overlap(closest_bb, fvgs)
                return closest_bb
        
        # Scenario B (Double BOS): Prioritize BB, fallback to OB
        elif scenario == ScenarioType.CONTINUATION_BOS:
            # 1. Look for Breaker Block first (strong trend)
            valid_bbs = [bb for bb in breaker_blocks if bb.is_valid()]
            if valid_bbs:
                current_price = df_itf['close'].iloc[-1]
                closest_bb = min(
                    valid_bbs,
                    key=lambda bb: abs((bb.price_high + bb.price_low) / 2 - current_price)
                )
                closest_bb.fvg_overlap = self.poi_detector.check_fvg_overlap(closest_bb, fvgs)
                return closest_bb
            
            # 2. Fallback to Order Block
            valid_obs = [ob for ob in order_blocks if ob.is_valid()]
            if valid_obs:
                current_price = df_itf['close'].iloc[-1]
                closest_ob = min(
                    valid_obs,
                    key=lambda ob: abs((ob.price_high + ob.price_low) / 2 - current_price)
                )
                closest_ob.fvg_overlap = self.poi_detector.check_fvg_overlap(closest_ob, fvgs)
                return closest_ob
        
        return None
    
    def validate_entry_conditions(
        self,
        df_ltf: pd.DataFrame,
        poi: PointOfInterest,
        structure_break: StructureBreak
    ) -> Tuple[bool, bool]:
        """
        Phase 3: Validate entry conditions on Lower Timeframe.
        
        Args:
            df_ltf: DataFrame with LTF data
            poi: Selected Point of Interest
            structure_break: Structure break from ITF
            
        Returns:
            Tuple of (inducement_swept, fvg_validation)
        """
        # Check if inducement has been swept
        inducement = self.structure_detector.identify_inducement(
            df_ltf,
            structure_break
        )
        
        inducement_swept = False
        if inducement:
            current_price = df_ltf['close'].iloc[-1]
            if structure_break.direction == TrendDirection.BULLISH:
                inducement_swept = df_ltf['low'].iloc[-5:].min() <= inducement.price
            else:
                inducement_swept = df_ltf['high'].iloc[-5:].max() >= inducement.price
        
        # Validate FVG overlap requirement
        fvg_validation = False
        if poi.poi_type == POIType.ORDER_BLOCK:
            fvg_validation = poi.fvg_overlap
        elif poi.poi_type == POIType.BREAKER_BLOCK:
            fvg_validation = poi.fvg_overlap  # Unicorn model
        else:
            fvg_validation = True  # FVG itself is valid
        
        return inducement_swept, fvg_validation
    
    def calculate_risk_levels(
        self,
        poi: PointOfInterest,
        direction: str,
        current_price: float,
        htf_context: Dict,
        itf_structure: Dict,
        symbol: str = "EURUSD"
    ) -> Dict:
        """
        Phase 4: Calculate risk management levels with proper TP placement.
        
        TP1: External liquidity (high/low formed before the pullback/inducement)
        TP2: Next significant high/low on higher timeframe
        Minimum R:R for TP1 is 1:2 (NO MAXIMUM - can be 1:20, 1:50, etc.)
        
        Args:
            poi: Selected Point of Interest
            direction: Trade direction ('BUY' or 'SELL')
            current_price: Current market price
            htf_context: HTF context for liquidity levels
            itf_structure: ITF structure analysis for external liquidity
            symbol: Trading symbol for pip calculation
            
        Returns:
            Dictionary with entry, SL, and TP levels with accurate pips
        """
        # Calculate entry price
        if poi.poi_type == POIType.BREAKER_BLOCK:
            entry_price = poi.get_entry_price("breaker")
        else:
            entry_price = poi.get_entry_price("standard")
        
        # Determine pip value based on symbol type
        if 'JPY' in symbol:
            pip_value = 0.01  # JPY pairs
        elif any(x in symbol for x in ['XAU', 'XAG', 'GOLD', 'SILVER']):
            pip_value = 0.01  # Gold/Silver
        elif any(x in symbol for x in ['BTC', 'ETH', 'CRYPTO']):
            pip_value = 1.0  # Crypto
        elif any(x in symbol for x in ['US30', 'NAS100', 'SPX500', 'US500', 'DOW', 'NASDAQ']):
            pip_value = 1.0  # Indices
        else:
            pip_value = 0.0001  # Standard forex pairs
        
        # Calculate Stop Loss (distal line + padding in actual pip value)
        if direction == "BUY":
            distal_line = poi.price_low
            stop_loss = distal_line - (self.sl_padding_pips * pip_value)
        else:  # SELL
            distal_line = poi.price_high
            stop_loss = distal_line + (self.sl_padding_pips * pip_value)
        
        # Calculate risk amount (actual price difference)
        risk_amount = abs(entry_price - stop_loss)
        
        # Calculate Take Profits based on liquidity zones
        # NO MAXIMUM R:R - can be 1:2, 1:10, 1:50, whatever the market offers
        if direction == "BUY":
            # TP1: External Liquidity (high formed before the pullback)
            tp1_target = None
            
            # Look for the swing high that was broken before the pullback
            swing_highs = itf_structure.get('swing_highs', [])
            if len(swing_highs) >= 1:
                # External liquidity is the most recent swing high
                tp1_target = swing_highs[-1].price
            
            # If no swing high found or it's below entry, use minimum R:R
            if tp1_target is None or tp1_target <= entry_price:
                take_profit_1 = entry_price + (risk_amount * 2.0)  # Minimum 1:2
            else:
                take_profit_1 = tp1_target
            
            # Ensure MINIMUM 1:2 R:R for TP1 (but allow higher)
            min_tp1 = entry_price + (risk_amount * 2.0)
            if take_profit_1 < min_tp1:
                take_profit_1 = min_tp1
            
            # TP2: Next significant high on HTF (NO LIMIT on R:R)
            tp2_target = None
            htf_swing_highs = htf_context.get('swing_highs', [])
            
            # Find the next HTF swing high above TP1
            for swing_high in reversed(htf_swing_highs):
                if swing_high.price > take_profit_1:
                    tp2_target = swing_high.price
                    break
            
            # If found a valid HTF target, use it (regardless of R:R)
            if tp2_target is not None and tp2_target > take_profit_1:
                take_profit_2 = tp2_target
            else:
                # Fallback: minimum 1:3 R:R
                take_profit_2 = entry_price + (risk_amount * 3.0)
            
            # Final check: TP2 must be above TP1
            if take_profit_2 <= take_profit_1:
                take_profit_2 = entry_price + (risk_amount * 3.0)
        
        else:  # SELL
            # TP1: External Liquidity (low formed before the pullback)
            tp1_target = None
            
            # Look for the swing low that was broken before the pullback
            swing_lows = itf_structure.get('swing_lows', [])
            if len(swing_lows) >= 1:
                # External liquidity is the most recent swing low
                tp1_target = swing_lows[-1].price
            
            # If no swing low found or it's above entry, use minimum R:R
            if tp1_target is None or tp1_target >= entry_price:
                take_profit_1 = entry_price - (risk_amount * 2.0)  # Minimum 1:2
            else:
                take_profit_1 = tp1_target
            
            # Ensure MINIMUM 1:2 R:R for TP1 (but allow higher)
            max_tp1 = entry_price - (risk_amount * 2.0)
            if take_profit_1 > max_tp1:
                take_profit_1 = max_tp1
            
            # TP2: Next significant low on HTF (NO LIMIT on R:R)
            tp2_target = None
            htf_swing_lows = htf_context.get('swing_lows', [])
            
            # Find the next HTF swing low below TP1
            for swing_low in reversed(htf_swing_lows):
                if swing_low.price < take_profit_1:
                    tp2_target = swing_low.price
                    break
            
            # If found a valid HTF target, use it (regardless of R:R)
            if tp2_target is not None and tp2_target < take_profit_1:
                take_profit_2 = tp2_target
            else:
                # Fallback: minimum 1:3 R:R
                take_profit_2 = entry_price - (risk_amount * 3.0)
            
            # Final check: TP2 must be below TP1
            if take_profit_2 >= take_profit_1:
                take_profit_2 = entry_price - (risk_amount * 3.0)
        
        # Calculate ACTUAL risk-reward ratios (can be any value >= 2.0)
        rr_tp1 = abs(take_profit_1 - entry_price) / risk_amount if risk_amount > 0 else 0
        rr_tp2 = abs(take_profit_2 - entry_price) / risk_amount if risk_amount > 0 else 0
        
        return {
            'entry_price': entry_price,
            'stop_loss': stop_loss,
            'take_profit_1': take_profit_1,
            'take_profit_2': take_profit_2,
            'risk_amount': risk_amount,
            'risk_reward_tp1': rr_tp1,
            'risk_reward_tp2': rr_tp2,
            'pip_value': pip_value  # Include for accurate pip calculations
        }
    
    def generate_trading_setup(
        self,
        df_htf: pd.DataFrame,
        df_itf: pd.DataFrame,
        df_ltf: pd.DataFrame,
        symbol: str,
        ml_prediction: Optional[Dict] = None,
        sentiment_score: Optional[Dict] = None
    ) -> Optional[TradingSetup]:
        """
        Generate complete trading setup by combining all analysis phases.
        
        Args:
            df_htf: Higher timeframe DataFrame
            df_itf: Intermediate timeframe DataFrame
            df_ltf: Lower timeframe DataFrame
            symbol: Trading symbol (for accurate pip calculations)
            ml_prediction: ML model predictions (optional)
            sentiment_score: Sentiment analysis results (optional)
            
        Returns:
            TradingSetup object or None if no valid setup
        """
        # Phase 1: HTF Context
        htf_context = self.analyze_htf_context(df_htf)
        
        # Check if HTF trend is clear
        if htf_context['trend'] == TrendDirection.RANGING:
            return None
        
        # Phase 2: ITF Setup
        scenario, structure_break = self.analyze_itf_setup(df_itf, htf_context)
        
        if scenario == ScenarioType.NO_SETUP or structure_break is None:
            return None
        
        # Get ITF structure analysis (needed for TP calculation)
        itf_structure = self.structure_detector.analyze_market_structure(df_itf)
        
        # Select POI
        poi = self.select_optimal_poi(scenario, structure_break, htf_context, df_itf)
        
        if poi is None:
            return None
        
        # Phase 3: LTF Validation
        inducement_swept, fvg_validation = self.validate_entry_conditions(
            df_ltf,
            poi,
            structure_break
        )
        
        # Check validation requirements
        if not fvg_validation:
            return None
        
        # Determine direction
        direction = "BUY" if structure_break.direction == TrendDirection.BULLISH else "SELL"
        
        # Phase 4: Calculate risk levels with symbol-specific pip values
        current_price = df_ltf['close'].iloc[-1]
        risk_levels = self.calculate_risk_levels(
            poi, 
            direction, 
            current_price, 
            htf_context,
            itf_structure,
            symbol  # Pass symbol for accurate pip calculation
        )
        
        # Calculate confidence score
        confidence_score = self._calculate_confidence_score(
            scenario=scenario,
            inducement_swept=inducement_swept,
            fvg_validation=fvg_validation,
            ml_prediction=ml_prediction,
            sentiment_score=sentiment_score,
            direction=direction
        )
        
        # Create trading setup
        setup = TradingSetup(
            scenario=scenario,
            direction=direction,
            poi=poi,
            entry_price=risk_levels['entry_price'],
            stop_loss=risk_levels['stop_loss'],
            take_profit_1=risk_levels['take_profit_1'],
            take_profit_2=risk_levels['take_profit_2'],
            risk_reward_tp1=risk_levels['risk_reward_tp1'],
            risk_reward_tp2=risk_levels['risk_reward_tp2'],
            structure_context=htf_context,
            inducement_swept=inducement_swept,
            fvg_validation=fvg_validation,
            confidence_score=confidence_score,
            timestamp=df_ltf.index[-1] if hasattr(df_ltf.index, 'to_timestamp') else pd.Timestamp.now()
        )
        
        return setup
    
    def _calculate_confidence_score(
        self,
        scenario: ScenarioType,
        inducement_swept: bool,
        fvg_validation: bool,
        ml_prediction: Optional[Dict],
        sentiment_score: Optional[Dict],
        direction: str
    ) -> float:
        """
        Calculate confidence score for the trading setup.
        
        Args:
            scenario: Trading scenario
            inducement_swept: Whether inducement was swept
            fvg_validation: Whether FVG validation passed
            ml_prediction: ML predictions
            sentiment_score: Sentiment analysis
            direction: Trade direction
            
        Returns:
            Confidence score between 0 and 1
        """
        score = 0.0
        
        # Base score from SMC components (60% weight)
        smc_score = 0.0
        
        # Scenario type (15%)
        if scenario == ScenarioType.CONTINUATION_BOS:
            smc_score += 0.15  # Higher confidence for continuation
        else:
            smc_score += 0.10  # Lower for reversal
        
        # Inducement swept (15%)
        if inducement_swept:
            smc_score += 0.15
        
        # FVG validation (15%)
        if fvg_validation:
            smc_score += 0.15
        
        # POI quality (15%)
        smc_score += 0.15  # Assume valid POI
        
        score += smc_score
        
        # ML prediction score (25% weight)
        if ml_prediction:
            ml_score = 0.0
            ensemble_prediction = ml_prediction.get('ensemble', 0)
            ml_confidence = ml_prediction.get('confidence', 0.0)
            
            # Check if ML agrees with direction
            if (direction == "BUY" and ensemble_prediction == 1) or \
               (direction == "SELL" and ensemble_prediction == -1):
                ml_score = 0.25 * ml_confidence
            
            score += ml_score
        
        # Sentiment score (15% weight)
        if sentiment_score:
            sentiment_value = sentiment_score.get('score', 0.0)
            sentiment_confidence = sentiment_score.get('confidence', 0.0)
            
            # Check if sentiment agrees with direction
            if (direction == "BUY" and sentiment_value > 0) or \
               (direction == "SELL" and sentiment_value < 0):
                score += 0.15 * sentiment_confidence
        
        # Normalize to 0-1 range
        score = min(1.0, max(0.0, score))
        
        return round(score, 2)
    
    def should_take_trade(
        self,
        setup: TradingSetup,
        min_confidence: float = 0.6,
        min_risk_reward: float = 2.0  # Updated to minimum 1:2
    ) -> Tuple[bool, str]:
        """
        Determine if a trade should be taken based on criteria.
        
        Args:
            setup: Trading setup
            min_confidence: Minimum confidence score required
            min_risk_reward: Minimum risk-reward ratio required (default 1:2)
            
        Returns:
            Tuple of (should_trade, reason)
        """
        # Check confidence
        if setup.confidence_score < min_confidence:
            return False, f"Confidence too low: {setup.confidence_score} < {min_confidence}"
        
        # Check risk-reward ratio (minimum 1:2)
        if setup.risk_reward_tp1 < min_risk_reward:
            return False, f"Risk-reward too low: 1:{setup.risk_reward_tp1:.2f} < 1:{min_risk_reward}"
        
        # Check FVG validation
        if not setup.fvg_validation:
            return False, "FVG validation failed"
        
        # All checks passed
        return True, "All criteria met"


if __name__ == "__main__":
    # Test SMC Analyzer
    print("Testing SMC Analyzer...")
    
    # Create sample data for testing
    dates = pd.date_range('2024-01-01', periods=500, freq='1H')
    
    # HTF data (4H timeframe)
    df_htf = pd.DataFrame({
        'open': np.random.uniform(100, 110, 500),
        'high': np.random.uniform(110, 115, 500),
        'low': np.random.uniform(95, 100, 500),
        'close': np.random.uniform(100, 110, 500),
        'volume': np.random.uniform(1000, 2000, 500)
    }, index=dates)
    
    # ITF data (1H timeframe)
    df_itf = pd.DataFrame({
        'open': np.random.uniform(100, 110, 500),
        'high': np.random.uniform(110, 115, 500),
        'low': np.random.uniform(95, 100, 500),
        'close': np.random.uniform(100, 110, 500),
        'volume': np.random.uniform(1000, 2000, 500)
    }, index=dates)
    
    # LTF data (15M timeframe)
    df_ltf = pd.DataFrame({
        'open': np.random.uniform(100, 110, 500),
        'high': np.random.uniform(110, 115, 500),
        'low': np.random.uniform(95, 100, 500),
        'close': np.random.uniform(100, 110, 500),
        'volume': np.random.uniform(1000, 2000, 500)
    }, index=dates)
    
    # Initialize analyzer
    analyzer = SMCAnalyzer()
    
    # Generate setup
    setup = analyzer.generate_trading_setup(df_htf, df_itf, df_ltf)
    
    if setup:
        print("\nTrading Setup Generated:")
        print(f"Scenario: {setup.scenario.value}")
        print(f"Direction: {setup.direction}")
        print(f"Entry: {setup.entry_price}")
        print(f"Stop Loss: {setup.stop_loss}")
        print(f"TP1: {setup.take_profit_1} (RR: {setup.risk_reward_tp1})")
        print(f"TP2: {setup.take_profit_2} (RR: {setup.risk_reward_tp2})")
        print(f"Confidence: {setup.confidence_score}")
        
        should_trade, reason = analyzer.should_take_trade(setup)
        print(f"\nShould Take Trade: {should_trade}")
        print(f"Reason: {reason}")
    else:
        print("\nNo valid setup found")
    
    print("\nSMC Analyzer test completed!")