"""
ML Model Ensemble - COMPLETE
Author: BLESSING OMOREGIE
GitHub: Nixiestone
Repository: nyx_trial

DO NOT EDIT THIS FILE
Combines all 3 ML models for robust predictions.
"""

import numpy as np
import pandas as pd
from typing import Dict, Optional
from pathlib import Path

from .random_forest_model import RandomForestModel
from .gradient_boosting_model import GradientBoostingModel
from .lstm_model import LSTMModel
from ..utils.logger import get_logger


class MLEnsemble:
    """
    Ensemble of 3 ML models for trading predictions.
    Combines Random Forest, Gradient Boosting, and LSTM.
    """
    
    def __init__(self, config):
        """
        Initialize ML ensemble.
        
        Args:
            config: Settings object
        """
        self.config = config
        self.logger = get_logger(__name__, config.LOG_LEVEL, config.LOG_FILE_PATH)
        
        # Initialize all three models
        self.model1 = RandomForestModel(config)
        self.model2 = GradientBoostingModel(config)
        self.model3 = LSTMModel(config, sequence_length=60)
        
        self.ensemble_threshold = config.ML_ENSEMBLE_THRESHOLD
        
        self.logger.info("ML Ensemble initialized with 3 models")
    
    def train_all(
        self,
        df: pd.DataFrame,
        labels: np.ndarray
    ) -> Dict:
        """
        Train all three models.
        
        Args:
            df: DataFrame with OHLCV data
            labels: Array of labels (-1, 0, 1)
            
        Returns:
            Dictionary with training results for all models
        """
        self.logger.info("Training all models in ensemble...")
        
        results = {}
        
        # Train Model 1: Random Forest
        try:
            results['model1'] = self.model1.train(df, labels)
        except Exception as e:
            self.logger.error(f"Model 1 training failed: {e}")
            results['model1'] = {'error': str(e)}
        
        # Train Model 2: Gradient Boosting
        try:
            results['model2'] = self.model2.train(df, labels)
        except Exception as e:
            self.logger.error(f"Model 2 training failed: {e}")
            results['model2'] = {'error': str(e)}
        
        # Train Model 3: LSTM
        try:
            results['model3'] = self.model3.train(df, labels, epochs=50)
        except Exception as e:
            self.logger.error(f"Model 3 training failed: {e}")
            results['model3'] = {'error': str(e)}
        
        self.logger.info("All models trained")
        
        return results
    
    def predict(self, df: pd.DataFrame) -> Dict:
        """
        Generate ensemble prediction from all models.
        
        Args:
            df: DataFrame with OHLCV data
            
        Returns:
            Dictionary with predictions from all models and ensemble
        """
        try:
            # Get predictions from all models
            pred1, conf1 = self.model1.predict(df)
            pred2, conf2 = self.model2.predict(df)
            pred3, conf3 = self.model3.predict(df)
            
            self.logger.debug(
                f"Individual predictions: "
                f"M1={pred1}({conf1:.2f}), "
                f"M2={pred2}({conf2:.2f}), "
                f"M3={pred3}({conf3:.2f})"
            )
            
            # Combine predictions
            predictions = np.array([pred1, pred2, pred3])
            confidences = np.array([conf1, conf2, conf3])
            
            # Weighted voting based on confidence
            weighted_votes = {}
            for pred, conf in zip(predictions, confidences):
                if pred not in weighted_votes:
                    weighted_votes[pred] = 0
                weighted_votes[pred] += conf
            
            # Get ensemble prediction (highest weighted vote)
            ensemble_pred = max(weighted_votes, key=weighted_votes.get)
            
            # Calculate ensemble confidence
            total_weight = sum(weighted_votes.values())
            ensemble_conf = weighted_votes[ensemble_pred] / total_weight if total_weight > 0 else 0.33
            
            # Check agreement level
            unique_preds = np.unique(predictions)
            agreement = len(predictions[predictions == ensemble_pred]) / len(predictions)
            
            result = {
                'model1': int(pred1),
                'model1_confidence': float(conf1),
                'model2': int(pred2),
                'model2_confidence': float(conf2),
                'model3': int(pred3),
                'model3_confidence': float(conf3),
                'ensemble': int(ensemble_pred),
                'confidence': float(ensemble_conf),
                'agreement': float(agreement),
                'all_agree': len(unique_preds) == 1
            }
            
            self.logger.model_prediction("ENSEMBLE", result)
            
            return result
            
        except Exception as e:
            self.logger.exception(f"Error in ensemble prediction: {e}")
            return {
                'model1': 0,
                'model1_confidence': 0.33,
                'model2': 0,
                'model2_confidence': 0.33,
                'model3': 0,
                'model3_confidence': 0.33,
                'ensemble': 0,
                'confidence': 0.33,
                'agreement': 0.33,
                'all_agree': False
            }
    
    def get_model_status(self) -> Dict:
        """
        Get status of all models.
        
        Returns:
            Dictionary with model statuses
        """
        return {
            'model1_trained': self.model1.is_trained,
            'model2_trained': self.model2.is_trained,
            'model3_trained': self.model3.is_trained,
            'all_trained': (
                self.model1.is_trained and
                self.model2.is_trained and
                self.model3.is_trained
            )
        }
    
    def save_all(self):
        """Save all models to disk."""
        self.logger.info("Saving all models...")
        
        try:
            self.model1.save()
            self.logger.info("Model 1 saved")
        except Exception as e:
            self.logger.error(f"Failed to save Model 1: {e}")
        
        try:
            self.model2.save()
            self.logger.info("Model 2 saved")
        except Exception as e:
            self.logger.error(f"Failed to save Model 2: {e}")
        
        try:
            self.model3.save()
            self.logger.info("Model 3 saved")
        except Exception as e:
            self.logger.error(f"Failed to save Model 3: {e}")
        
        self.logger.info("All models saved")
    
    def load_all(self):
        """Load all models from disk."""
        self.logger.info("Loading all models...")
        
        try:
            self.model1.load()
            self.logger.info("Model 1 loaded")
        except Exception as e:
            self.logger.warning(f"Failed to load Model 1: {e}")
        
        try:
            self.model2.load()
            self.logger.info("Model 2 loaded")
        except Exception as e:
            self.logger.warning(f"Failed to load Model 2: {e}")
        
        try:
            self.model3.load()
            self.logger.info("Model 3 loaded")
        except Exception as e:
            self.logger.warning(f"Failed to load Model 3: {e}")
        
        status = self.get_model_status()
        self.logger.info(f"Model status: {status}")
    
    def requires_training(self) -> bool:
        """
        Check if models need training.
        
        Returns:
            True if any model is not trained
        """
        status = self.get_model_status()
        return not status['all_trained']
    
    def get_prediction_summary(self, df: pd.DataFrame) -> str:
        """
        Get human-readable prediction summary.
        
        Args:
            df: DataFrame with OHLCV data
            
        Returns:
            String summary of predictions
        """
        prediction = self.predict(df)
        
        direction_map = {-1: "SELL", 0: "NEUTRAL", 1: "BUY"}
        
        summary = f"""
ML ENSEMBLE PREDICTION:
-----------------------
Model 1 (Random Forest): {direction_map[prediction['model1']]} ({prediction['model1_confidence']*100:.1f}%)
Model 2 (Gradient Boost): {direction_map[prediction['model2']]} ({prediction['model2_confidence']*100:.1f}%)
Model 3 (LSTM): {direction_map[prediction['model3']]} ({prediction['model3_confidence']*100:.1f}%)

ENSEMBLE: {direction_map[prediction['ensemble']]} 
Confidence: {prediction['confidence']*100:.1f}%
Agreement: {prediction['agreement']*100:.1f}%
All models agree: {'Yes' if prediction['all_agree'] else 'No'}
        """
        
        return summary.strip()


if __name__ == "__main__":
    # Test ML Ensemble
    from config.settings import settings
    
    print("Testing ML Ensemble...")
    
    # Create sample data
    dates = pd.date_range('2023-01-01', periods=1000, freq='1H')
    df = pd.DataFrame({
        'open': np.random.uniform(100, 110, 1000),
        'high': np.random.uniform(110, 115, 1000),
        'low': np.random.uniform(95, 100, 1000),
        'close': np.random.uniform(100, 110, 1000),
        'volume': np.random.uniform(1000, 2000, 1000)
    }, index=dates)
    
    # Create sample labels (simulate price direction)
    labels = np.random.choice([-1, 0, 1], size=1000, p=[0.3, 0.4, 0.3])
    
    # Initialize ensemble
    ensemble = MLEnsemble(settings)
    
    # Check initial status
    print("\nInitial Status:")
    print(ensemble.get_model_status())
    
    # Train all models
    print("\nTraining all models...")
    results = ensemble.train_all(df, labels)
    
    print("\nTraining Results:")
    for model_name, metrics in results.items():
        if 'error' not in metrics:
            acc_key = 'accuracy' if 'accuracy' in metrics else 'train_accuracy'
            print(f"  {model_name}: {metrics.get(acc_key, 0):.4f}")
    
    # Check status after training
    print("\nStatus After Training:")
    print(ensemble.get_model_status())
    
    # Make prediction
    print("\nMaking Prediction...")
    prediction = ensemble.predict(df)
    
    print(f"\nEnsemble Prediction: {prediction['ensemble']}")
    print(f"Confidence: {prediction['confidence']:.4f}")
    print(f"Agreement: {prediction['agreement']:.4f}")
    print(f"All Agree: {prediction['all_agree']}")
    
    # Get summary
    print("\n" + "="*50)
    print(ensemble.get_prediction_summary(df))
    print("="*50)
    
    print("\nML Ensemble test completed!")